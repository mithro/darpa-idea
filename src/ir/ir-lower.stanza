defpackage rtm/ir-lower :
  import core
  import collections
  import rtm/ir
  import rtm/ir/errors
  import rtm/ir-utils
  import rtm/utils
  import rtm/errors
  import stz/algorithms with :
    prefix(FreeList) => stz-
  import rtm/property-merge

;============================================================
;===================== Standard Passes ======================
;============================================================

public defn lower (prog:List<TStmt>, flattener:RefFlattener) -> Collection<TStmt> :
  ;Remove all errors that this pass is detecting
  remove-errors({_ is InappropriatePart
                    | NoAppropriatePart
                    | DuplicateReferenceDesignator
                    | NoPackageForInst
                    | NoPoseForInst
                    | NoSideForInst
                    | NoPoseForInst
                    | NoSideForInst
  })
  end-if-errors()

  ;Construct irtable
  var ir-table:IRTable = IRTable(prog)
  defn update-ir-table (prog:Collection<TStmt>) :
    ir-table = IRTable(prog)
    prog

  ;Solve
  check-schematic-groups $
  check-inst-poses $
  add-reference-designators $  
  inline-modules{ir-table, _, flattener} $
  update-ir-table $
  expand-nets{ir-table, _} $
  solve-mappings{ir-table, _} $
  prog

public defn lower (prog:List<TStmt>) :
  lower(prog, DefaultFlattener())

;<doc>=======================================================
;============== Retrieve All Pin Properties =================
;============================================================

PEntry levels:
  For each PinPropertiesStmt at level l:
    if statement is inherited from a DefComponent then:
      statements within support options are at level INT-MAX - 1
      statements at DefComponent level are at level INT-MAX
    else if statement is at the module level then:
      statements within support options are at level (2 * l)
      statements at module level are at level (2 * l + 1)

;============================================================
;=======================================================<doc>    

public defn pin-properties (ir-table:IRTable, m:DefModule) -> [Tuple<PinPropertiesStmt>, Mapping] :
  ;Tables
  val supported-by-stmts = Vector<SupportedByStmt>()
  val source-table = HashTable<Ref,InstStmt|InstSupportsStmt>()
  val option-table = HashTable<Ref,SupportOption>()
  val pentries = Vector<PEntry>()

  ;Overall algorithm
  defn driver () :
    build-tables()      
    compute-pin-properties()    

  ;Fill out supported-by-stmts, source-table, and module-option-table
  defn build-tables () :
    for s in stmts(m) do :
      match(s) :
        (s:SupportedByStmt) :
          add(supported-by-stmts, s)
        (s:InstStmt) :
          val inst-name = Ref(name(s))
          defn prefix-inst (r:Ref) :
            dot(inst-name, r)
          defn prefix-inst (s:PinPropertiesStmt) :
            sub-ref(s, prefix-inst(ref(s)))
          defn prefix-inst (m:Mapping) :
            Mapping $ for entry in mappings(m) map :
              key(entry) => prefix-inst(value(entry))
          defn prefix-inst (o:SupportOption) :
            SupportOption(
              prefix-inst(id(o) as Ref),
              requires(o),
              map(prefix-inst, properties(o)),
              prefix-inst(mapping(o)))
          source-table[inst-name] = s
          val ctable = ctable(ir-table, component(s))
          for p in seq(prefix-inst, pin-properties(ctable)) do :
            make-pentry(entries(p), ref(p), INT-MAX)
          for s in supports(ctable) do :
            for o in seq(prefix-inst, options(s)) do :
              option-table[id(o) as Ref] = o
        (s:InstSupportsStmt) :
          source-table[inst(s)] = s
          for o in options(s) do :
            option-table[dot(inst(s), id(o) as Ref)] = o
        (s:PinPropertiesStmt) :
          make-pentry(entries(s), ref(s), 2 * level(s) + 1)
        (s) : false

  ;Make a SinglePin PEntry out of given arguments
  defn make-pentry (entries:Tuple<KeyValue<Symbol,?>>, ref:Ref, level:Int) :
    val entry = new PEntry :
      defmethod properties (this) : entries
      defmethod ref (this) : ref
      defmethod level (this) : level
      defmethod type (this) : SinglePin()
      defmethod print (o:OutputStream, this) :
        print(o, "PEntry(%_, %_, %_)" % [ref, level, entries])
    add(pentries, entry) 
  
  ;Retrieve bindings and properties given by supported-by statement
  ;return: (props:List<PinPropertiesStmt>, from-component?:True|False) -> ?
  defn get-bindings+properties (return:(List<PinPropertiesStmt>, True|False) -> ?, s:SupportedByStmt) -> Mapping :
    ;First retrieve the instance from which the port was requested.
    ;It will either be an inst or an inst-supports.
    match(source-table[base(ref(s))]) :
      (src:InstStmt) :
        ;Retrieve the SupportOption corresponding to
        ;component C and option-id(s).
        val option = option-table[option-id(s)]
        val bindings* = apply-mappings(ref(s), mapping(option))
        return(properties(option), true)
        bindings*
      (src:InstSupportsStmt) :
        ;First build table with nested bindings
        val binding-table = HashTable<Ref,Ref>()
        for s in nested-supports(s) do :
          val mappings = mappings(get-bindings+properties(return, s))
          for entry in mappings do :
            binding-table[key(entry)] = value(entry)
        
        ;Retrieve the SupportOption corresponding to option-id(s).
        val option = option-table[option-id(s)]
        val properties* = sub-bindings(properties(option), binding-table)
        val mappings* = sub-bindings(mapping(option), binding-table)
        val bindings* = apply-mappings(ref(s), mappings*)
        return(properties*, false)
        bindings*        

  ;Make appropriate remappings in the given Supports properties using the
  ;given binding table.
  defn sub-bindings (ss:List<PinPropertiesStmt>, bindings:Table<Ref,Ref>) :
    for s in ss map :
      sub-ref(s, get?(bindings, ref(s), ref(s)))
      
  ;Make appropriate remappings in the given capability mappings using the
  ;given bindings table
  defn sub-bindings (m:Mapping, bindings:Table<Ref,Ref>) :
    Mapping $ for entry in mappings(m) map :
      val v = value(entry)
      key(entry) => get?(bindings,v,v)

  ;Apply the capability mappings given in m:
  ;e.g. i2c.sda => insta.p[0]
  ;     i2c.scl => instb.p[4]
  ;to the given port:
  ;e.g. myinst.mic
  ;Output should be:
  ;e.g. myinst.mic.sda => insta.p[0]
  ;     myinst.mic.scl => instb.p[4]
  defn apply-mappings (port:Ref, m:Mapping) :
    Mapping $ for entry in mappings(m) map :
      sub-head(key(entry), port) => value(entry)
  
  ;Compute pin properties, and mappings
  defn compute-pin-properties () :
    ;Accumulate all computed mappings
    val all-bindings = Vector<KeyValue<Ref,Ref>>()
    
    ;pentries list already holds entries inherited by non-supports properties
    ;Now add the properties from the supports statements.
    for s in supported-by-stmts do :
      val bindings = 
        within (pin-props, from-component?) = get-bindings+properties(s) :
          for p in pin-props do :
            val level = (INT-MAX - 1) when from-component?
                   else 2 * level(p) 
            make-pentry(/entries(p), ref(p), level)
      add-all(all-bindings, mappings(bindings))
    val properties* = to-tuple(merge-pin-properties(ir-table, pentries))

    ;Return new properties and bindings
    [properties*, Mapping(to-list(all-bindings))]

  ;Launch algorithm
  driver()

;============================================================
;==================== Post Lower ============================
;============================================================

;Substitute concrete pins
public defn substitute-concrete-pins (prog:Collection<TStmt>) :
  ;Substitute all concrete pins annotated by supported-by statements.
  defn sub-pins (ir-table:IRTable, m:DefModule) :
    ;First compute the pin properties and mapping
    ;annotated by the supported-by statements.
    val [pin-props, mapping] = pin-properties(ir-table, m)

    ;Next create the function 'sub-bindings' for processing a MStmt
    ;by substituting all the annotated bindings.
    val binding-table = to-hashtable<Ref,Ref>(mappings(mapping))
    defn sub-bindings (s:MStmt) :
      defn sub-binding (r:Ref) : get?(binding-table, r, r)
      map-scope-refs(sub-binding, s)

    val stmts* = Vector<MStmt>()
    for s in stmts(m) do :
      match(s) :
        ;Remove previous statements
        (s:PinPropertiesStmt) : false
        (s:InstSupportsStmt) : false
        (s:RequireStmt) : false
        (s:SupportsStmt) : false
        (s:SupportedByStmt) : false
        ;Substitute binding for other statements
        (s) : add(stmts*, sub-bindings(s))        
    add-all(stmts*, pin-props)
    sub-stmts(m, to-list(stmts*))

  ;Apply transformations on all top-level modules
  within (ir-table, defm) = map-top-modules(prog) :
    post-lower(ir-table, sub-pins(ir-table, defm))    

;Final lowering pass to be done after requirements and concrete pins have been assigned.
defn post-lower (ir-table:IRTable, m:DefModule) :
  ;Retrieve tables
  val mtable = MTable(m)
  val menv = ModuleEnv(ir-table, name(m))


  ;Construct new statements
  val stmts* = to-list $
    undot-refs{ir-table, _, KicadFlattener()} $
    group-nets{ir-table, _, false} $
    stmts(m)
  sub-stmts(m, stmts*)

;============================================================
;===================== Mapping Solver =======================
;============================================================

defn solve-mappings (env:TypeEnv, m:Mapping, defaults:Seqable<Ref>) -> Mapping :
  val mt = MappingTable(env, true, mentries) where :
    val mentries = Vector<MapEntry>()
    ;Add defaults
    for p in defaults do :
      add(mentries, MapEntry(p, p, 0, 0))
    ;Add mapping
    for [ref, pin] in kvs(mappings(m)) do :
      add(mentries, MapEntry(ref, pin))
  ;Create new mapping
  Mapping $ to-list $ for e in mt seq :
    key(e) => ref(e)

defn solve-mappings (env:TypeEnv, mapping:Mapping) :
  solve-mappings(env, mapping, List())

defn solve-mappings (ir-table:IRTable, m:DefModule) :
  ;Retrieve the module environment
  val env = ModuleEnv(ir-table, name(m))

  ;Retrieve the pins of an inst
  defn InstEnv (inst:Ref) :
    val c-name = component(env[inst] as InstType)
    CMEnv(ir-table, c-name)
  defn inst-pins (inst:Ref) :
    val c-name = component(env[inst] as InstType)
    seq(Ref{name(_)}, pins(cmtable(ir-table, c-name)))

  ;Substitute new statements
  val stmts* = Vector<MStmt>()
  val pin-stmts = IntTable<List<PinPropertiesStmt>>(List())
  for s in stmts(m) do :
    match(s) :
      (s:PackageStmt) :
        match(package(s)) :
          ([pak, m]:[Symbol Mapping]) :
            val m* = solve-mappings(InstEnv(ref(s)), m, inst-pins(ref(s)))
            add(stmts*, sub-package(s, [pak, m*]))
          (f:False) :
            add(stmts*, s)
      (s:RequireStmt) :
        add(stmts*, solve-mappings(ir-table, s))
      (s:SupportsStmt) :
        add(stmts*, solve-mappings(ir-table, env, s))
      (s:InstSupportsStmt) :
        add(stmts*, solve-mappings(ir-table, env, s))
      (s:PinPropertiesStmt) :
        update(pin-stmts, cons{s, _}, level(s))
      (s) :
        add(stmts*, s)
  for entry in pin-stmts do :
    add-all(stmts*, expand-properties(env, value(entry), key(entry)))
  sub-stmts(m, to-list(stmts*))

defn solve-mappings (ir-table:IRTable, c:DefComponent) :
  val env = ComponentEnv(ir-table, name(c))
  val pin-refs = map(Ref{name(_)}, pins(c))
  val stmts* = Vector<CStmt>()
  val pin-stmts = Vector<PinPropertiesStmt>()
  for s in stmts(c) do :
    match(s) :
      (s:DefaultPackageStmt) :
        add(stmts*, sub-mapping(s, solve-mappings(env, mapping(s), pin-refs)))
      (s:SupportsStmt) :
        add(stmts*, solve-mappings(ir-table, env, s))
      (s:PinPropertiesStmt) :
        add(pin-stmts, s)
      (s) :
        add(stmts*, s)
  add-all(stmts*, expand-properties(env, pin-stmts))
  sub-stmts(c, to-list(stmts*))

defn solve-mappings (ir-table:IRTable, r:RequireStmt) :
  val lhs-env = CapabilityEnv(ir-table, Ref(name(r)), capability(r))
  sub-mapping(r, solve-mappings(lhs-env, mapping(r)))

defn solve-mappings (ir-table:IRTable, env:TypeEnv, s:InstSupportsStmt) :
  val supports* = solve-mappings(ir-table, env, supports-stmt(s))
  InstSupportsStmt(inst(s), supports*)

defn solve-mappings (ir-table:IRTable, env:TypeEnv, s:SupportsStmt) :
  val lhs-env = CapabilityEnv(ir-table, Ref(capability(s)), Capability(capability(s)))
  val options* = for option in options(s) map :
    val id* = make-default-id(id(option))
    val requires* = map(solve-mappings{ir-table, _}, requires(option))
    val mapping* = solve-mappings(lhs-env, mapping(option))
    val properties* = expand-properties(SupportOptionEnv(env, option), properties(option))
    sub-mapping{_, mapping*} $
    sub-requires{_, requires*} $
    sub-id{_, id*} $
    sub-properties{_, properties*} $
    option
  sub-options(s, options*)

defn make-default-id (id:Ref|False) :
  match(id:Ref) : id
  else : Ref(gensym(`s))

defn expand-properties (env:TypeEnv, ps:Seqable<PinPropertiesStmt>) :
  expand-properties(env, ps, 0)

defn expand-properties (env:TypeEnv, ps:Seqable<PinPropertiesStmt>, level:Int) :
  val pentries = for s in ps seq :
    new PEntry :
      defmethod properties (this) : entries(s)
      defmethod ref (this) : ref(s)
      defmethod level (this) : level
      defmethod type (this) : env[ref(s)] as PinType
  val penv = new PEnv<PinPropertiesStmt> :
    defmethod expand (this, r:Ref, t:PinType) : expand(env, r, t)
    defmethod make-entry (this, r:Ref, es:Tuple<KeyValue<Symbol,?>>) : PinPropertiesStmt(r, level, es)
  to-list(merge-properties(penv, pentries))

defn solve-mappings (ir-table:IRTable, prog:Seqable<TStmt>) :
  to-list $ for s in prog seq :
    match(s) :
      (s:DefComponent) : solve-mappings(ir-table, s)
      (s:DefModule) : solve-mappings(ir-table, s)
      (s) : s

;============================================================
;=================== Expand Nets ============================
;============================================================

defn expand-nets (ir-table:IRTable, prog:Collection<TStmt>) :
  to-tuple $ for s in prog seq :
    match(s) :
      (m:DefModule) : expand-nets(ir-table, m)
      (s) : s

defn expand-nets (ir-table:IRTable, m:DefModule) :
  val env = ModuleEnv(ir-table, name(m))
  val stmts* = for s in stmts(m) seq-append :
    match(s) :
      (s:NetStmt) :
        if empty?(refs(s)) :
          List()
        else :
          val type = env[head(refs(s))] as PinType
          val refss = map(expand{env, _}, refs(s))
          match(ref(s)) :
            (name-ref:False) :
              to-list(seq(RefNetStmt{false, _}, seq(to-list, zip-all(refss))))
            (name-ref:Ref) :
              val name-refs = expand(ir-table, name-ref, type)
              to-list(seq(RefNetStmt, name-refs, seq(to-list, zip-all(refss))))
      (s) :
        List(s)
  sub-stmts(m, stmts*)

;============================================================
;================== Module Inlining =========================
;============================================================
defn inline-modules (ir-table:IRTable, prog:Collection<TStmt>, flattener:RefFlattener) :
  ;Discover top-level modules
  val top-modules = to-tuple(top-modules(ir-table))

  ;Collected program
  val module-table = HashTable<Symbol,DefModule|DefComponent>()
  for s in prog do :
    match(s:DefModule|DefComponent) :
      module-table[name(s)] = s

  ;Forward Declarations
  var inline-module

  ;Inline statements
  defn inline-stmts (ss:Seqable<MStmt>, env:TypeEnv) :
    ;All component instances pointed to by ref.
    ;If r points to a component, then just return it.
    ;If r points to a module, return all instances of all components in module
    defn all-insts (r:Ref) :
      generate<Ref> :
        val t = env[r] as InstType|InstArray
        val refs = expand(r, t)
        val base-cmp = component(base(t))
        match(inline-module(base-cmp)) :
          (m:DefModule) :
            for stmt in stmts(m) do :
              val istmt = inlined-stmt(stmt)
              match(istmt:InstStmt) :
                val mrefs = expand(inlined-ref!(stmt), type(istmt))
                for r in refs do :
                  for mr in mrefs do :
                    yield(dot(r, mr))
          (m:DefComponent) :
            do(yield, refs)

    generate<MStmt> :
      for s in ss do :
        match(s) :
          (s:InstStmt) :
            val component = name(base(type(s)))
            val refs = expand(Ref(name(s)), type(s))
            match(inline-module(component)) :
              (m:DefModule) :
                for ref in refs do :
                  for stmt in cat(pins(m), stmts(m)) do :
                    yield(dot(ref, stmt))
              (m:DefComponent) :
                yield(s)
          (s:SchematicGroupStmt) :
            ;Two cases:
            ;Case 1: Ref refers to a pin
            ;  Expand pin reference.
            ;Case 2: Ref refers to an instance(s) of a module/component
            ;  Expand schematic group
            match(env[ref(s)]) :
              ;Case 1
              (t:PinType) :
                val refs* = expand(env, ref(s), t)
                do(yield{sub-ref(s, _)}, refs*)
              (t:InstType|InstArray) :
                val refs* = all-insts(ref(s))
                do(yield{sub-ref(s, _)}, refs*)
          (s) :
            yield(s)

  defn inline (m:DefModule) :
    val env = ModuleEnv(ir-table, name(m))
    val stmts* =
      to-list $
      inline-stmts{_, env} $
      resolve-class-selectors $
      stmts(m)
    sub-stmts(m, stmts*)

  inline-module = memoize<Symbol> $ fn (name) :
    match(module-table[name]) :
      (c:DefComponent) : c
      (m:DefModule) : inline(m)
      
  ;Inline all modules, and perform merges
  to-tuple $ for s0 in prog seq :
    match(s0:DefModule) :
      val env = ModuleEnv(ir-table, name(s0))
      val s = inline-module(name(s0)) as DefModule
      val stmts* =
        to-list $
        resolve-defaults{ir-table, _} $
        undot-refs{ir-table, _, flattener} $
        group-nets{ir-table, _, true} $
        make-merges{_, flattener} $
        stmts(s)
      sub-stmts(s, stmts*)
    else : s0

defn dot (r:Ref, s:MStmt|Pin) :
  match(s) :
    (s:Pin) : InlinedStmt(1, r, NodeStmt(name(s), type(s)))
    (s:InlinedStmt) : InlinedStmt(inline-level(s) + 1, dot(r, ref(s)), stmt(s))
    (s:MStmt) : InlinedStmt(1, r, s)

;============================================================
;================= Resolve Class Selectors ==================
;============================================================
defn resolve-class-selectors (ss:Seqable<MStmt>) :
  ;Collect instances and statements with class selectors
  val insts = HashTable<Symbol, List<Ref>>(List())
  val stmts = Vector<PackageStmt>()

  generate<MStmt> :
    ;Scan through statements
    for s in ss do :
      match(s) :
        (s:InstStmt) :
          yield(s)
          val refs = expand(Ref(name(s)), type(s))
          val component = name(base(type(s)))
          update(insts, append{refs, _}, component)
        (s:PackageStmt) :
          if instance?(s) : yield(s)
          else : add(stmts, s)
        (s) :
          yield(s)
    ;Break out statements
    for s in stmts do :
      val class = name!(ref(s))
      for inst in insts[class] do :
        yield(sub-ref(s, inst))

;============================================================
;================== Inlined Statements ======================
;============================================================
defstruct InlinedStmt <: MStmt :
  inline-level: Int with: (as-method => true)
  ref: Ref
  stmt: MStmt with: (updater => sub-stmt)

defmethod print (o:OutputStream, s:InlinedStmt) :
  print(o, "inlined(%_): %_" % [ref(s), stmt(s)])

defmulti inline-level (m:MStmt) -> Int
defmethod inline-level (m:MStmt) : 0

defn inlined-stmt (s:MStmt) :
  match(s:InlinedStmt) : stmt(s)
  else : s

defn map-inlined (f:MStmt -> MStmt, s:MStmt) :
  match(s:InlinedStmt) : sub-stmt(s, f(stmt(s)))
  else : f(s)

defn inlined (f:MStmt -> Ref, s:MStmt) :
  match(s) :
    (s:InlinedStmt) : dot(ref(s), f(stmt(s)))
    (s:MStmt) : f(s)

defn inlined (f:MStmt -> List<Ref>, s:MStmt) :
  match(s) :
    (s:InlinedStmt) : map(dot{ref(s), _}, f(stmt(s)))
    (s:MStmt) : f(s)

defn inlined-anchor (s:MStmt) :
  val a = anchor(inlined-stmt(s) as PackageStmt)
  match(s, a) :
    (s:InlinedStmt, a:False) : ref(s)
    (s:InlinedStmt, a:Ref) : dot(ref(s), a)
    (s, a) : a


defn inlined-ref! (s:MStmt) :
  inlined-ref?(s) as Ref

defn inlined-ref? (s:MStmt) :
  val mref = match(inlined-stmt(s)) :
    (mst:InstStmt|NodeStmt) : Ref(name(mst))
    (mst:InstSupportsStmt|RequireStmt) : inst(mst)
    (mst:PackageStmt|EModelStmt|PartStmt|ReferenceStmt|
         NetStmt|SchematicGroupStmt|PinPropertiesStmt) : ref(mst)     
    (mst) : fatal("No reference in %_" % [mst])
  match(s:InlinedStmt, mref:Ref) : dot(ref(s), mref)
  else : mref

;Special helper NetStmt
defmulti ref (s:NetStmt) -> Ref|False
defmethod ref (s:NetStmt) :
  match(name(s)) :
    (name:Symbol) : Ref(name)
    (name:False) : false

defn RefNetStmt (ref:Ref|False, refs:List<Ref>) :
  new NetStmt :
    defmethod name (this) : match(ref:Ref) : to-symbol(ref)
    defmethod ref (this) : ref
    defmethod refs (this) : refs
    defmethod sub-refs (this, refs*:List<Ref>) : RefNetStmt(ref, refs*)

;============================================================
;==================== Merges ================================
;============================================================

defn make-merges (ss:Seqable<MStmt>, flattener:RefFlattener) :
  ;Table groups
  val package-name = MergeTable<Ref,[Symbol,Mapping]>(override)
  val package-pose = RelativeTable()
  val emodels = MergeTable<Ref,EModel>(merge)
  val parts = MergeTable<Ref,PartStmt|InlinedStmt>(override)
  val ref-designators = MergeTable<Ref,ReferenceStmt|InlinedStmt>(override)
  val schematic-groups = MergeTable<[Ref, Int|False],SchematicGroupStmt|InlinedStmt>(override)
  val insts = HashSet<Ref>()

  generate<MStmt> :
    ;Convenience function
    defn yield? (x:MStmt|False) :
      match(x:MStmt) : yield(x)

    ;Build table
    for s in ss do :
      match(inlined-stmt(s)) :
        (mst:PackageStmt) :
          val [r, l] = [inlined-ref!(s), inline-level(s)]
          attempt:
            package-name[r,l] = package(mst) as? [Symbol, Mapping]
          attempt :
            val ps = match(pose(mst)) :
              (p:False) : side(mst) as? Side
              (p:Pose) : p
            package-pose[r,l] = RelEntry(ps, inlined-anchor(s))
        (mst:EModelStmt) :
          emodels[inlined-ref!(s), inline-level(s)] = model(mst)
        (mst:PartStmt) :
          parts[inlined-ref!(s), inline-level(s)] = s as PartStmt|InlinedStmt
        (mst:ReferenceStmt) :
          ref-designators[inlined-ref!(s), inline-level(s)] = s as ReferenceStmt|InlinedStmt
        (mst:SchematicGroupStmt) :
          schematic-groups[[inlined-ref!(s), unit(mst)], inline-level(s)] = s as SchematicGroupStmt|InlinedStmt
        (mst:InstStmt) :
          for r in expand(inlined-ref!(s), type(mst)) do :
            add(insts, r)
            set-inst(package-pose, r)
          yield(s)
        (mst) :
          yield(s)

    ;Symbol and Package statements
    for ref in insts do :
      ;Retrieve value/anchor from table.
      defn pose? (t:RelativeTable, r:Ref) :
        attempt: pose(t[r] as? RelEntry)
      defn anchor? (t:RelativeTable, r:Ref) :
        attempt: anchor(t[r] as? RelEntry)
      yield?(PackageStmt?(ref, package-name[ref], pose, side,
                          anchor?(package-pose, ref))) where :
        val [pose, side] = split-pose-side?(pose?(package-pose, ref))

    for [inst, emodel] in kvs(emodels) do :
      yield(EModelStmt(inst, emodel))
    do(yield{value(_)}, parts)
    do(yield{value(_)}, ref-designators)
    do(yield{value(_)}, schematic-groups)



defn PackageStmt? (r:Ref, nm:[Symbol,Mapping]|False, pose:Pose|False, side:Side|False, anchor:Ref|False) :
  match(nm:False, pose:False, side:False) : false
  else : PackageStmt(r, true, nm, pose, side, anchor)


defn apply-pose-side (a:Pose|Side, b:Pose|Side) :
  match(a, b) :
    (a:Pose, b:Pose) : apply(a, b)
    (a:Pose, b:Side) : flip(side(a), b)
    (a:Side, b:Pose) : fatal("Loss of information.")
    (a:Side, b:Side) : flip(a, b)

defn more-information? (a:Pose|Side, b:Pose|Side) :
  match(a:Pose, b:Side) : true

defn inv-pose-side (x:Pose|Side) :
  match(x) :
    (x:Pose) : inverse(x)
    (x:Side) : x

defn split-pose-side? (x:Pose|Side|False) -> [Pose|False, Side|False] :
  match(x) :
    (x:Pose) : [x, side(x)]
    (x:Side) : [false, x]
    (x:False) : [false, false]

;============================================================
;=================== RelativeTable ==========================
;============================================================
deftype RelativeTable
defmulti set (t:RelativeTable, r:Ref, level:Int, e:RelEntry) -> False
defmulti get (t:RelativeTable, r:Ref) -> RelEntry|False
defmulti set-inst (t:RelativeTable, r:Ref) -> False

defstruct RelEntry :
  pose: Pose|Side
  anchor: Ref|False
with: (printer => true)

defn RelativeTable () :
  ;Accumulate table
  val levels = HashTable<Ref,Int>()
  val entries = HashTable<Ref, RelEntry>()
  defn put (r:Ref, l:Int, e:RelEntry) :
    defn put-entry () :
      entries[r] = e
      levels[r] = l
    match(get?(levels,r)) :
      (l0:Int) : put-entry() when l < l0
      (f:False) : put-entry()

  ;Track instances
  val insts = HashSet<Ref>()

  ;Flatten chains
  defn flatten-chains () :
    val flattened = HashSet<Ref>()
    defn flatten (r:Ref) :
      val result = match(get?(entries,r)) :
        (e:RelEntry) : e when flattened[r] else flatten(e)
        (f:False) : false
      match(result:RelEntry) :
        entries[r] = result
      add(flattened, r)
      result

    defn flatten (e:RelEntry) :
      match(anchor(e)) :
        (a:Ref) :
          match(flatten(a)) :
            (e0:RelEntry) :
              if more-information?(pose(e), pose(e0)) : e
              else : RelEntry(apply-pose-side(pose(e0), pose(e)), anchor(e0))
            (f:False) : e
        (a:False) :
          e
    do(flatten, keys(entries))

  ;Reanchor
  defn reanchor () :
    ;Find all floating anchor groups
    val anchor-groups = group-by(entry-anchor, filter(floating-anchor?, entries)) where :
      defn entry-anchor (e:KeyValue<Ref,RelEntry>) : anchor(value(e)) as Ref
      defn floating-anchor? (e:KeyValue<Ref,RelEntry>) :
        match(anchor(value(e))) :
          (a:Ref) : not insts[a]
          (a) : false
    ;The best anchor is the one that's an instance and with the most information.
    defn reanchor (a:Ref, group-entries:List<KeyValue<Ref,RelEntry>>) :
      val inst-entries = to-list(filter(inst?, group-entries)) where :
        defn inst? (e:KeyValue<Ref,RelEntry>) : insts[key(e)]
      if not empty?(inst-entries) :
        val a* = minimum(inst-entries, better-anchor?) where :
          defn better-anchor? (a:KeyValue<Ref,RelEntry>, b:KeyValue<Ref,RelEntry>) :
            more-information?(pose(value(a)), pose(value(b)))
        val inv-pa = inv-pose-side(pose(value(a*)))
        val a0 = key(a*)
        for e in group-entries do :
          ;New anchoring point
          if key(e) == key(a*) :
            match(get?(entries, a)) :
              (e0:RelEntry) : entries[key(e)] = e0
              (f:False) : remove(entries, key(e))
          ;Other entries
          else :
            val pose* = apply-pose-side(inv-pa, pose(value(e)))
            entries[key(e)] = RelEntry(pose*, a0)
        ;Move old anchoring point
        entries[a] = RelEntry(inv-pa, key(a*))
    for [a, entries] in kvs(anchor-groups) do :
      reanchor(a, entries)

  ;Process
  var processed? = false
  defn ensure-processed () :
    if not processed? :
      flatten-chains()
      reanchor()
      processed? = true

  new RelativeTable :
    defmethod set (this, r:Ref, level:Int, e:RelEntry) : put(r, level, e)
    defmethod set-inst (this, r:Ref) : (add(insts, r), false)
    defmethod get (this, r:Ref) :
      ensure-processed()
      get?(entries, r)

;============================================================
;==================== MergeTable ============================
;============================================================

deftype MergeTable<K,T> <: Collection<KeyValue<K,T>>
defmulti set<?K,?T> (t:MergeTable<?K,?T>, k:K, level:Int, v:T) -> False
defmulti get<?K,?T> (t:MergeTable<?K,?T>, k:K) -> T|False

defn MergeTable<K,T> (merge:(T,T) -> T) :
  ;Vector holding tables for all levels
  val table = HashTable<K,[T, Int]>()

  new MergeTable<K,T> :
    defmethod to-seq (this) :
      for [k, [v, l]] in kvs(table) seq :
        k => v
    defmethod set (this, k:K, l:Int, v:T) :
      table[k] =
        if key?(table, k) :
          val [v0, l0] = table[k]
          val v* = if l < l0 : merge(v, v0)
                   else : merge(v0, v)
          [v*, min(l, l0)]
        else :
          [v, l]
    defmethod get (this, k:K) :
      if key?(table, k) :
        val [v, l] = table[k]
        v

;============================================================
;================== Net Accumulation ========================
;============================================================

defn group-nets (ir-table:IRTable, ss:Seqable<MStmt>, keep-nodes?:True|False) :
  ;Analyze statements
  val stmts = Vector<MStmt>()
  val net-stmts = Vector<InlinedStmt|NetStmt>()
  val node-stmts = Vector<InlinedStmt|NodeStmt>()
  val node-set = HashSet<Ref>()  
  for s in ss do :
    add(stmts, s)
    match(inlined-stmt(s)) :
      (mst:NetStmt) :
        add(net-stmts, s as NetStmt|InlinedStmt)
      (mst:NodeStmt) :
        val r = inlined-ref!(s)
        add-all(node-set, expand(ir-table, r, type(mst)))
      (mst) : false

  ;Construct Net Table
  val net-table = NetTable(net-stmts)


  ;Find the earliest, highest-level, named net reference for a given net group
  ;Returns false if there is no single named net in this group.
  defn net-ref (g:NetGroup) -> Ref|False :
    ; Figure out the name of the NetGroup g
    ; Names are decided in the following priority:
    ; 1. Explicit net names
    ; 2. Module pin/port names (higher level modules take precedence)
    ; 3. Part(PCBComponent) pin/port names

    ;Compares net index a against net index b.
    ;Returns true if we should prioritize net a's name over net b's.
    ;Returns false if we should prioritize net b's name over net a.
    defn less-net? (a:Int, b:Int) -> True|False :
      ; Retrieve nets at index a and b (na, and nb)
      val na = net-stmts[a]
      val nb = net-stmts[b]
      ;Retrieve the net name (which is a Ref because we're still in the middle of inlining).
      ;ra, rb are the names of nets a and b respectively.
      ;They are false if the nets don't have names.
      val ra = ref(inlined-stmt(na) as NetStmt)
      val rb = ref(inlined-stmt(nb) as NetStmt)
      ;If either of these has a name, and the other one doesn't. Then prioritize that one.
      val c = match(ra, rb) :
        (refa:Ref, refb:False) : -1
        (refa:False, refb:Ref) : 1
        (refa, refb) : 0
      ; The net closer to the top of the hierarchy takes precedence
      if c == 0 :
        ;Retrieve the levels of nets a and b (l1 and l2)
        val l1 = inline-level(net-stmts[a])
        val l2 = inline-level(net-stmts[b])
        ;If they are the same level, then prioritize the net
        ;that occurs earlier (the one with the smaller index).
        if l1 == l2 : a < b
        ;Otherwise, prioritize net a if it is at a lower level (closer to the top
        ;of the hierarchy).
        else : l1 < l2
      ; Default: Just pick a net to take precedence
      else :
        c == -1

    ;Find the highest priority net (which is the 'minimum' set
    ;according to the comparison function defined above.)
    val i = minimum(nets(g), less-net?)

    ;Retrieve the name of net i
    val net-ref = inlined-ref?(net-stmts[i])
    ;Return the name if it is not false
    match(net-ref:Ref) :
      net-ref
    else :
      ;Otherwise, we calculate a name from one of the pins on
      ;the net.
      val r = minimum(refs(g), {length(_) < length(_)})
      FieldRef(r, `net)

  ;If the given reference is a node, then return another reference on the same net.
  ;Otherwise return the given node.
  ;Returns false if the given reference is a node, but not part of a net.
  defn node-ref (r:Ref) :
    if node-set[r] :
      match(group-id(net-table, r)) :
        (i:False) :
          false
        (i:Int) :
          val g = group(net-table, i)
          find({not node-set[_]}, refs(g))
    else :
      r


  ;Generate statements
  generate<MStmt> :
    defn yield? (s:MStmt|False) :
      match(s:MStmt) : yield(s)
    if keep-nodes? :
      ;Yield rest of stmts
      for s in stmts do :
        match(inlined-stmt(s)) :
          (_:NetStmt) : false
          (_) : yield(s)
      ;Yield nets
      for g in groups(net-table) do :
        ;Yield the net and geoms
        val net-ref = net-ref(g)
        yield(RefNetStmt(net-ref, refs(g)))
    else :
      ;Yield rest of stmts
      for s in stmts do :
        match(inlined-stmt(s)) :
          (_:NetStmt|NodeStmt) : false
          (_:PinPropertiesStmt) : yield(s) when not node-set[inlined-ref!(s)]
          (_) : yield(s)
      ;Yield nets
      for g in groups(net-table) do :
        val refs* = to-list(filter({not node-set[_]}, refs(g)))
        if length(refs*) > 1 :
          ;Yield the net and geoms
          val net-ref = net-ref(g)
          yield(RefNetStmt(net-ref, refs*))

;============================================================
;==================== Net Table =============================
;============================================================

deftype NetTable
defmulti groups (t:NetTable) -> Seqable<NetGroup>
defmulti group-id (t:NetTable, r:Ref) -> Int|False
defmulti group (t:NetTable, i:Int) -> NetGroup

defstruct NetGroup :
  id: Int
  nets: List<Int>
  refs: List<Ref>
defmethod print (o:OutputStream, n:NetGroup) :
  print(o, "netgroup(%_, %~, %~)" % [id(n), nets(n), refs(n)])

;Returns a sequence of net groups
;Each group contains in the indices of all nets in the group, and all
;refs in the group.
defn NetTable (nets:Vector<NetStmt|InlinedStmt>) -> NetTable :
  ;UFSets
  ; genid guarantees a unique integer every time it's called
  defn make-set () : UFSet(genid())
  ; Make a UFSet for every net statement
  val net-sets = HashTable-init<Ref|Int,UFSet<Int>>(make-set{})
  val ref-sets = HashTable-init<Ref,UFSet<Int>>(make-set{})

  defn get-net-set (net:NetStmt|InlinedStmt, net-i:Int):
    match(inlined-ref?(net)):
      (name:Ref) : net-sets[name]
      (name:False) : net-sets[net-i]

  ;Add to sets
  for (net in nets, net-i in 0 to false) do :
    val net-set = get-net-set(net, net-i)
    for ref in inlined(refs{_ as NetStmt}, net) do :
      merge!(net-set, ref-sets[ref])

  ;Collect nets and refs
  val net-groups = IntTable<List<Int>>(List())
  val ref-groups = IntTable<List<Ref>>(List())
  for (net in nets, net-i in 0 to false) do :
    update(net-groups, cons{net-i, _}, root-value(get-net-set(net, net-i)))
  for entry in ref-sets do :
    val [ref, ref-set] = [key(entry), value(entry)]
    update(ref-groups, cons{ref, _}, root-value(ref-set))

  ;Return table
  new NetTable :
    defmethod groups (this) :
      for entry in ref-groups seq :
        val id = key(entry)
        val net-refs = ref-groups[id]
        if empty?(net-refs) : fatal("Invalid empty net %_" % [id])
        NetGroup(id, net-groups[id], net-refs)
    defmethod group-id (this, r:Ref) :
      root-value(ref-sets[r])
    defmethod group (this, id:Int) :
      NetGroup(id, net-groups[id], ref-groups[id])

;============================================================
;======================= Undot ==============================
;============================================================
;TODO: Note that instances are still flattened here.
;      which we shouldn't do. 

defn undot-refs (ir-table:IRTable, ss:Seqable<MStmt>, f:RefFlattener) :
  ;Stores the flattened version of each reference
  val ref-table = HashTable<Ref, VarRef>()

<<<<<<< HEAD
  ;Add to rename table
  defn rename-to (r:Ref, r2:VarRef) :
    ref-table[r] = r2

=======
>>>>>>> 91ead84f5ccab218fdb43062b3a1776d4f20afaa
  ;Rename using the ref table
  defn rename (r:Ref) :
    if key?(ref-table, r) :
      ref-table[r]
    else :
      match(r) :
        (r:VarRef) : r
        (r:FieldRef) : FieldRef(rename(ref(r)), name(r))
        (r:IndexRef) : IndexRef(rename(ref(r)), index(r))
  defn rename (f:False) : f

  ;Net counter
  defn ref* (st:NetStmt) :
    match(ref(st)) :
      (ref:Ref) : ref
      (ref:False) : Ref(gensym(`noname))

  ;Flatten an inlined statement
  defn flatten-inlined (s:MStmt) :
    match(s:InlinedStmt) :
      defn dot (r:Ref) : /dot(ref(s), r)
      defn dot (sym:Symbol) : flatten(f, /dot(ref(s), Ref(sym)))
      defn dot (o:SupportOption) :
        val properties* = map(add-level, properties(o))
        sub-properties(o, properties*)
      defn add-level (p:PinPropertiesStmt) :
        sub-level(p, inline-level(s) + level(p))
      match(map-scope-refs(dot, stmt(s))) :
        (st:SupportsStmt) : InstSupportsStmt(ref(s), capability(st), map(dot,options(st)))
        (st:InstSupportsStmt) : InstSupportsStmt(dot(inst(st)), capability(st), map(dot,options(st)))
        (st:InstStmt) : sub-name(st, dot(name(st)))
        (st:NodeStmt) : sub-name(st, dot(name(st)))
        (st:SchematicGroupStmt) : sub-group(st, dot(group(st)))
        (st:NetStmt) : sub-name(st, flatten(f,dot(ref*(st))))
        (st:PinPropertiesStmt) : add-level(st)
        (st) : st
    else :
      match(s) :
        (s:NetStmt) :
          NetStmt(flatten(f, ref*(s)), refs(s))
        (s) : s

  generate<MStmt> :
    for s0 in ss do :
      match(flatten-inlined(s0)) :
        (s:NetStmt) :
          match(inlined-ref?(s0)) :
<<<<<<< HEAD
            (ref:Ref) : rename-to(ref, Ref(name(s)))
=======
            (ref:Ref) : ref-table[ref] = Ref(name(s))
>>>>>>> 91ead84f5ccab218fdb43062b3a1776d4f20afaa
            (ref:False) : false
          yield(sub-refs(s, map(rename, refs(s))))
        (s:NodeStmt) :
          val ref = inlined-ref!(s0)
<<<<<<< HEAD
          rename-to(ref, Ref(name(s)))
=======
          ref-table[ref] = Ref(name(s))
>>>>>>> 91ead84f5ccab218fdb43062b3a1776d4f20afaa
          yield(s)
        (s:InstStmt) :
          val insts = expand(inlined-ref!(s0), type(s))
          val base-t = base(type(s))
          for inst in insts do :
            val name = flatten(f, inst)
<<<<<<< HEAD
            rename-to(inst, Ref(name))
            yield(InstStmt(name, base-t))
        (s:InstSupportsStmt) :
          val inst* = VarRef(flatten(f, inst(s)))
          rename-to(inst(s), inst*)
          val s* = map-scope-refs(rename, s) as InstSupportsStmt
          yield(sub-inst(s*, inst*))
=======
            ref-table[inst] = Ref(name)
            yield(InstStmt(name, base-t))
>>>>>>> 91ead84f5ccab218fdb43062b3a1776d4f20afaa
        (s) :
          yield(map-scope-refs(rename, s))

;============================================================
;==================== Resolve Defaults ======================
;============================================================

defn resolve-defaults (irtable:IRTable, ss:Seqable<MStmt>) :
  ;Instances, Symbols and Package statements
  val insts = HashTable<Ref,InstStmt>()
  val packages = HashTable<Ref,PackageStmt>()
  val emodels = HashTable<Ref,EModelStmt>()
  val parts = HashTable<Ref,PartStmt>()
  val estates = HashTable<Ref,EStateStmt>()

  ;Determines whether the default pin mapping is appropriate
  ;for the given component and package.
  defn pin-mapping? (component:Symbol, package-name:Symbol) :
    ;Retrieve set of component pins
    val component-pins = HashSet<Ref>()
    for port in pins(ctable(irtable, component)) do :
      val pins = expand(irtable, Ref(name(port)), type(port))
      add-all(component-pins, pins)

    ;Remove pins that have associated package pad
    for p in pads(ptable(irtable, package-name)) do :
      remove(component-pins, ref(p))

    ;If all component pins have an associated pad
    if empty?(component-pins) :
      val m = Mapping $ to-list $
        for port in pins(ctable(irtable, component)) seq-cat :
          for p in expand(irtable, Ref(name(port)), type(port)) seq :
            p => p
      [package-name, m]

  ;Inherit package property from part statement
  defn inherit-package (inst:InstStmt, pkgstmt:PackageStmt|False, partstmt:PartStmt|False) :
    match(partstmt:PartStmt) :
      match(pin-mapping?(component(inst), package(part(irtable, part(partstmt))))) :
        (pkg:[Symbol, Mapping]) :
          match(pkgstmt) :
            (pkgstmt:PackageStmt) :
              if package(pkgstmt) is False : sub-package(pkgstmt, pkg)
              else : pkgstmt
            (_:False) :
              PackageStmt(Ref(name(inst)), true, pkg, false, false, false)
        (_:False) :
          pkgstmt
    else : pkgstmt

  ;Scan through statements
  generate<MStmt> :
    ;yield if not false
    defn yield? (x:MStmt|False) :
      match(x:MStmt) : yield(x)
    for s in ss do :
      match(s) :
        (s:PackageStmt) : packages[ref(s)] = s
        (s:EModelStmt) : emodels[ref(s)] = s
        (s:PartStmt) : parts[ref(s)] = s
        (s:InstStmt) : (insts[Ref(name(s))] = s, yield(s))
        (s:EStateStmt) : (estates[ref(s)] = s, yield(s))
        (s) : yield(s)
    for inst in keys(insts) do :
      val ctable = ctable(irtable, component(insts[inst]))

      ;Yield the part statement
      val part-stmt = merge-default(inst, get?(parts, inst), default-part(ctable))
      yield?(part-stmt)


      ;Yield the package statement
      let :
        val pkgstmt = merge-default(inst, get?(packages, inst), default-package(ctable))
        yield?(inherit-package(insts[inst], pkgstmt, part-stmt))

      ;Yield the emodel statement
      val emodel-stmt = merge-default(inst, get?(emodels, inst), default-emodel(ctable))
      yield?(emodel-stmt)
      ;Grab emodel from part if appropriate
      match(emodel-stmt:False, part-stmt:PartStmt) :
        val m = emodel(part(irtable, part(part-stmt)))
        match(m:EModel) : yield(EModelStmt(inst, m))

      ;Yield electrical states
      for stmt in /estates(ctable) do :
        val pin = dot(inst, ref(stmt))
        yield(sub-ref(stmt, pin)) when not key?(estates, pin)

;============================================================
;===================== Merging Functions ====================
;============================================================

defn override<?T> (a:?T, b:?T) :
  a

defn merge (a:EModel, b:EModel) :
  defn merge-f (a, b) : b when a is False else b
  defn merge-n (a, b) : b when a is None else b
  match(a, b) :
    (a:Resistor, b:Resistor) :
      Resistor(merge-f(resistance(a), resistance(b)),
               merge-f(tolerance(a), tolerance(b)),
               merge-f(max-power(a), max-power(b)))
    (a:Capacitor, b:Capacitor) :
      Capacitor(merge-f(capacitance(a), capacitance(b)),
                merge-f(tolerance(a), tolerance(b)),
                merge-f(max-voltage(a), max-voltage(b)),
                merge-n(polarized?(a), polarized?(b)),
                merge-n(low-esr?(a), low-esr?(b)),
                merge-f(temperature-coefficient(a), temperature-coefficient(b)),
                merge-f(dielectric(a), dielectric(b)))
    (a:Inductor, b:Inductor) :
      Inductor(merge-f(inductance(a), inductance(b)),
               merge-f(tolerance(a), tolerance(b)),
               merge-f(max-current(a), max-current(b)))
    (a:Diode, b:Diode) :
      Diode(merge-f(forward-current(a), forward-current(b)),
            merge-f(forward-voltage(a), forward-voltage(b)),
            merge-f(max-current(a), max-current(b)),
            merge-f(max-reverse-voltage(a), max-reverse-voltage(b)),
            merge-f(color(a), color(b)),
            merge-f(luminous-intensity(a), luminous-intensity(b)))
    (a, b) :
      fatal("Cannot merge %_ with %_." % [a, b])


defn merge-default (ref:Ref, a:PackageStmt|False, b:DefaultPackageStmt) :
  match(package(a)) :
    (pa:False) : PackageStmt(ref, true, [package(b), mapping(b)], pose(a), side(a), anchor(a))
    (sb) : a

defn merge-default (ref:Ref, a:EModelStmt|False, b:DefaultEModelStmt) :
  match(a:EModelStmt) : EModelStmt(ref, merge(model(a), model(b)))
  else : EModelStmt(ref, model(b))

defn merge-default (ref:Ref, a:PartStmt|False, b:DefaultPartStmt) :
  match(a:PartStmt) : a
  else : PartStmt(ref, part(b))

defn merge-default<?T> (ref:Ref, a:?T, b:False) :
  a

;============================================================
;================= Reference Designators ====================
;============================================================

defn add-reference-designators (prog:Collection<TStmt>) :
  ;Used designators
  val used-refs = HashSet<String>()
  val id-lists = HashTable-init<String,Seq<Int>>(to-seq{0 to false})
  defn* next-ref (prefix:String) :
    val ref = string-join([prefix, next(id-lists[prefix])])
    if used-refs[ref] :
      next-ref(prefix)
    else :
      add(used-refs, ref)
      ref

  within (ir-table, defm) = map-top-modules(prog) :
    val mtable = mtable(ir-table, name(defm))

    ;Record all used references
    val referenced = HashSet<Symbol>()
    for rstmt in references(mtable) do :
      val inst = name!(ref(rstmt))
      fatal("%_ already has a reference!" % [ref(rstmt)]) when referenced[inst]
      add(referenced, inst)
      if used-refs[value(rstmt)] :
        report-error(DuplicateReferenceDesignator(inst, value(rstmt)))
      add(used-refs, value(rstmt))

    ;Give references to all instances without references
    val ref-stmts = for inst in insts(mtable) seq? :
      if referenced[name(inst)] :
        None()
      else :
        val prefix = match(reference-prefix(ctable(ir-table, component(inst)))) :
          (stmt:ReferencePrefixStmt) : prefix(stmt)
          (stmt:False) : "U"
        One(ReferenceStmt(Ref(name(inst)), next-ref(prefix)))

    ;Return new module
    sub-stmts(defm, to-list(cat(stmts(defm), ref-stmts)))

;============================================================
;================ Check Package Poses =======================
;============================================================

defn check-inst-poses (prog:Collection<TStmt>) :
  val ir-table = IRTable(prog)
  within defm = do-top-modules(ir-table, prog) :
    val m = name(defm)
    val mtable = mtable(ir-table, m)
    for inst in insts(mtable) do :
      match(package?(mtable, name(inst))) :
        (stmt:PackageStmt) :
          if package(stmt) is False :
            report-error(NoPackageForInst(m, name(inst), component(inst)))
          if pose(stmt) is False :
            report-error(NoPoseForInst(m, name(inst), component(inst)))
          if side(stmt) is False :
            report-error(NoSideForInst(m, name(inst), component(inst)))
        (stmt:False) :
          report-error(NoPackageForInst(m, name(inst), component(inst)))
          report-error(NoPoseForInst(m, name(inst), component(inst)))
          report-error(NoSideForInst(m, name(inst), component(inst)))

  prog


;============================================================
;=============== Check Schematic Group Bounds ===============
;============================================================

defn check-schematic-groups (prog:Collection<TStmt>) :
  within (ir-table, m) = do-top-modules(prog) :
    val mtable = mtable(ir-table, name(m))
    defn num-units (inst:Ref) -> Int|False :
      false
    for s in schematic-groups(mtable) do :
      val inst = base(ref(s))
      match(num-units(inst), unit(s)) :
        (num-units:Int, unit:Int) :
          report-error(SchematicGroupOutOfBounds(inst, num-units, unit)) when unit >= num-units
        (num-units, unit) : false
  prog

;============================================================
;========================= Utilities ========================
;============================================================
defn merge-pin-properties (ir-table:IRTable,
                           pentries:Seqable<PEntry>) ->
                           Seqable<PinPropertiesStmt> :
  val penv = new PEnv<PinPropertiesStmt> :
    defmethod expand (this, r:Ref, t:PinType) :
      expand(ir-table, r, t)
    defmethod make-entry (this, r:Ref, entries:Tuple<KeyValue<Symbol,?>>) :
      PinPropertiesStmt(r, 0, entries)
  merge-properties(penv, pentries)

defn value?<?T,?S> (f: T -> ?S, x:Maybe<?T>) :
  if not empty?(x) :
    f(value!(x))


defn symbol (x:False) : x
defn package (x:False) : x
defn pose (x:False) : x
defn side (x:False) : x
defn anchor (x:False) : x
defn name? (x:False) : x
defn name? (x:Ref) : name!(x)
