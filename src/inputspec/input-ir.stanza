defpackage input-spec/ir :
  import core
  import collections
  import reader
  import rtm/ir
  import rtm/ir-utils
  import rtm/utils
  

;============================================================
;====================== Interface ===========================
;============================================================

public defn parse-input-spec (filename:String) -> InputSpec :
  val forms = read-file(filename)
  parse-syntax[input-spec / #input-spec!](forms)

;============================================================
;===================== IR Datastructure =====================
;============================================================

public defstruct InputSpec :
  name: Symbol
  peripherals: List<Peripheral>
  connectors: List<Connector>
  board-shape: Shape|False

public defstruct Peripheral :
  name: Symbol
  config: List<KeyValue<Symbol,?>>
  pose: Pose|False
  side: Side|False

public defstruct Connector :
  name: Symbol
  config: List<KeyValue<Symbol,?>>
  interfaces: List<CInterface>
  pose: Pose|False
  side: Side|False

public defstruct CInterface :
  name: Symbol
  mapping: CPins

public deftype CPins
public defstruct CSinglePin <: CPins : (ref:Ref)
public defstruct CArray <: CPins : (pins:List<CPins>)
public defstruct CBundle <: CPins : (entries:List<KeyValue<Symbol,CPins>>)

defn non-negative! (d:String, v:Double) :
  if v < 0.0 :
    fatal("The value (%_) given to %_ cannot be negative." % [v, d])

;============================================================
;================== Internal Structures =====================
;============================================================

defstruct BoardStmt :
  shape: Shape

;============================================================
;================= Convenience Accessors ====================
;============================================================

public defn get (p:Peripheral, prop:Symbol) :
  lookup(config(p), prop)

;============================================================
;======================= Printer ============================
;============================================================

defn kv-printable (kv:KeyValue) :
  "%~ = %~" % [key(kv), value(kv)]

defmethod print (o:OutputStream, s:InputSpec) :
  val o2 = IndentedStream(o)
  print(o, "input-spec %~ :" % [name(s)])
  print-all(o2, pre-nl(peripherals(s)))
  print-all(o2, pre-nl(connectors(s)))
  val bs = board-shape(s)
  match(bs:Shape) :
    print(o2, "\n%_" % [BoardStmt(bs)])

defmethod print (o:OutputStream, p:Peripheral) :
  val o2 = IndentedStream(o)
  val pose-string = match(pose(p)) :
    (p:Pose) : " at %_" % [remove-flip(p)]
    (p:False) : ""
  val side-string = match(side(p)) :
    (s:Side) : " on %_" % [s]
    (s:False) : ""
  print(o, "%~%_%_%_" % [name(p), pose-string, side-string, colon?(config(p))])
  print-all(o2, pre-nl(seq(kv-printable, config(p))))

defmethod print (o:OutputStream, c:Connector) :
  val o2 = IndentedStream(o)
  val pose-string = match(pose(c)) :
    (p:Pose) : " at %_" % [remove-flip(p)]
    (p:False) : ""
  val side-string = match(side(c)) :
    (s:Side) : " on %_" % [s]
    (s:False) : ""
  print(o, "connector %~%_%_%_" % [name(c), pose-string, side-string, colon?(append(config(c), interfaces(c)))])
  print-all(o2, pre-nl(seq(kv-printable, config(c))))
  print-all(o2, pre-nl(interfaces(c)))

defmethod print (o:OutputStream, c:CInterface) :
  print(o, "%~ on %_" % [name(c), mapping(c)])

defmethod print (o:OutputStream, b:BoardStmt) :
  val o2 = IndentedStream(o)
  print(o, "board :")
  match(shape(b)) :
    (s:Rectangle) : print(o2, "\nshape = rectangle(%~, %~)" % [width(s), height(s)])
    (s) : print(o2, "\nshape = %~" % [shape(b)])

defmethod print (o:OutputStream, p:CPins) :
  print{o, _} $ match(p) :
    (p:CSinglePin) : ref(p)
    (p:CArray) : "[%,]" % [pins(p)]
    (p:CBundle) : "{%,}" % [entries(p)]

defn colon? (xs:List) :
  if empty?(xs) : ""
  else : " :"

defn remove-flip (p:Pose) :
  sub-flip-x?(p, false)

;============================================================
;======================== Reader ============================
;============================================================

deftype Stmt :
  Peripheral <: Stmt
  BoardStmt <: Stmt
  Connector <: Stmt

defsyntax input-spec :
  ;===== Utilities =====
  defn ut (x) : unwrap-token(x)

  ;===== Basics =====
  defproduction symbol : Symbol
  defrule symbol = (?x) when ut(x) is Symbol : ut(x)
  
  defproduction string : String
  defrule string = (?x) when ut(x) is String : ut(x)

  defproduction double : Double
  defrule double = (?x) when ut(x) is Double : ut(x)

  defproduction non-neg-double : Double
  defrule non-neg-double = (?x) when ut(x) is Double and ut(x) >= 0.0 : ut(x)

  defproduction int : Int
  defrule int = (?x) when ut(x) is Int : ut(x)

  defproduction non-neg-int : Int
  defrule non-neg-int = (?x) when ut(x) is Int and ut(x) >= 0 : ut(x)

  ;===== Identifiers =====
  defproduction id : Symbol
  defrule id != (.)
  defrule id != (=)
  defrule id != (:)
  defrule id != (=>)
  defrule id != (@do)
  defrule id != (@of)
  defrule id != (@tuple)
  defrule id != (@get)
  defrule id != (@afn)
  defrule id != (@do-afn)
  defrule id != (@cap)
  defrule id != (@quote)  
  defrule id = (?x:#symbol) : x

  ;===== Errors =====
  public defproduction input-spec! : InputSpec
  defrule input-spec! = (?x:#input-spec) : x
  fail-if input-spec! = () : ISE(closest-info(), "Input specification expected here.")
  
  defproduction id! : Symbol
  defrule id! = (?x:#id) : x
  fail-if id! = () : ISE(closest-info(), "Identifier expected here.")

  defproduction :! : Symbol
  defrule :! = (:) : (`:)
  fail-if :! = () : ISE(closest-info(), "Colon expected here.")

  defproduction on! : Symbol
  defrule on! = (on) : `on
  fail-if on! = () : ISE(closest-info(), "The on keyword is expected here.")

  defproduction =>! : Symbol
  defrule =>! = (=>) : `=>
  fail-if =>! = () : ISE(closest-info(), "The => operator is expected here.")

  defproduction pose! : Pose
  defrule pose! = (?x:#pose) : x
  fail-if pose! = () : ISE(closest-info(), "Pose expected here.")

  defproduction cstmt! : CInterface|KeyValue<Symbol,?>
  defrule cstmt! = (?x:#cstmt) : x
  fail-if cstmt! = () : ISE(closest-info(), "Expected either an interface or a parameter here.")

  defproduction cpins! : CPins
  defrule cpins! = (?x:#cpins) : x
  fail-if cpins! = () : ISE(closest-info(), "Connector pins expected here.")

  defproduction double! : Double
  defrule double! = (?x:#double) : x
  fail-if double! = () : ISE(closest-info(), "A double number expected here.")

  defproduction non-neg-double! : Double
  defrule non-neg-double! = (?x:#non-neg-double) : x
  fail-if non-neg-double! = () : ISE(closest-info(), "A non-negative double number expected here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : ISE(closest-info(), "An integer expected here.")

  defproduction non-neg-int! : Int
  defrule non-neg-int! = (?x:#non-neg-int) : x
  fail-if non-neg-int! = () : ISE(closest-info(), "A non-negative integer expected here.")

  defproduction non-neg-int$ : Int
  fail-if non-neg-int$ = (?x:#non-neg-int! ?rest) : ISE(closest-info(rest), "Unexpected input here.")
  defrule non-neg-int$ = (?x:#non-neg-int!) : x

  defproduction prop! : KeyValue<Symbol,?>
  defrule prop! = (?x:#prop) : x
  fail-if prop! = () : ISE(closest-info(), "Configuration property expected here.")

  defproduction stmt! : Stmt
  defrule stmt! = (?x:#stmt) : x
  fail-if stmt! = () : ISE(closest-info(), "Input specification statement expected here.")

  ;===== Productions =====
  public defproduction input-spec : InputSpec
  defrule input-spec = (input-spec ?name:#id! #:! (?stmts:#stmt! ...)) :
    val ps = to-list(filter-by<Peripheral>(stmts))
    val cs = to-list(filter-by<Connector>(stmts))
    val board = find({_ is BoardStmt}, stmts)
    val board-shape = attempt: shape(board as? BoardStmt)
    InputSpec(name, ps, cs, board-shape)

  defproduction stmt : Stmt
  defrule stmt = (board #:! (?ps:#prop! ...)) :
    val plist = PList{closest-info(), _, ps} $ [
      Property(`shape, false, true)]
    BoardStmt(
      property(plist, `shape))
  defrule stmt = (?c:#connector) :
    c
  defrule stmt = (?name:#id! ?pose+side:#pose+side? : (?ps:#prop! ...)) :
    val [pose, side] = pose+side
    Peripheral(name, ps, pose, side)
  defrule stmt = (?name:#id! ?pose+side:#pose+side?) :
    val [pose, side] = pose+side
    Peripheral(name, List(), pose, side)

  defproduction connector : Connector
  defrule connector = (connector ?name:#id! ?pose+side:#pose+side? ?stmts:#cstmts) :
    val [pose, side] = pose+side
    val config = Vector<KeyValue<Symbol,?>>()
    val interfaces = Vector<CInterface>()
    for s in stmts do :
      add{_, s} $ match(s) :
        (s:KeyValue<Symbol,?>) : config
        (s:CInterface) : interfaces    
    Connector(name, to-list(config), to-list(interfaces), pose, side)

  defproduction prop : KeyValue<Symbol,?>
  defrule prop = (voltage = ?v:#double!) : `voltage => v
  defrule prop = (current = ?v:#double!) : `current => v
  defrule prop = (shape = ?s:#shape!) : `shape => s
  defrule prop = (?name:#id! = ?v:#value!) : name => v

  defproduction value! : ?
  defrule value! = (?c:#connector) : c
  defrule value! = (?x) : unwrap-all(x)
  fail-if value! = () : ISE(closest-info(), "Expected a value here.")

  defproduction ref : Ref
  defrule ref = (?name:#id) : Ref(name)
  defrule ref = (?r:#ref . ?name:#id!) : FieldRef(r,name)
  defrule ref = (?r:#ref[?i:#non-neg-int$]) : IndexRef(r, i)
  
  defproduction cpins : CPins
  defrule cpins = ([?ps:#cpins! ...]) : CArray(ps)
  defrule cpins = ({(?fs:#id! #=>! ?ps:#cpins!) @...}) : CBundle(map(KeyValue,fs,ps))
  defrule cpins = (?r:#ref) : CSinglePin(r)

  defproduction cstmt : CInterface|KeyValue<Symbol,?>
  defrule cstmt = (?name:#id! on ?p:#cpins!) : CInterface(name, p)
  defrule cstmt = (?p:#prop) : p
  
  defproduction cstmts : List<CInterface|KeyValue<Symbol,?>>
  defrule cstmts = (: (?cs:#cstmt! ...)) : cs
  defrule cstmts = () : List()

  defproduction pose : Pose
  defrule pose = (loc(?x:#double!, ?y:#double!, ?angle:#double)) : loc(Point(x,y), angle, false)
  defrule pose = (loc(?x:#double!, ?y:#double!)) : loc(Point(x,y), 0.0, false)
  fail-if pose = (loc(_ ...)) :
    ISE(closest-info(), "Pose expression expects an x and y coordinate, and an optional angle.")

  defproduction pose+side? : [Pose|False, Side|False]
  defrule pose+side? = (?p:#pose? ?s:#side?) :
    match(p, s) :
      (p:False, s) : [false, s]
      (p:Pose, s:Top) : [p, s]
      (p:Pose, s:Bottom) : [sub-flip-x?(p,true), s]
      (p:Pose, s:False) : [p, Top]

  defproduction pose? : Pose|False
  defrule pose? = (at ?p:#pose!) : p
  defrule pose? = () : false

  defproduction side? : Side|False
  defrule side? = (on Top) : Top
  defrule side? = (on Bottom) : Bottom
  fail-if side? = (on) : ISE(closest-info(), "Side expected here.")
  defrule side? = () : false

  defproduction shape! : Shape
  defrule shape! = (polygon(?p0:#point!, ?p1:#point!, ?p2:#point!, ?ps:#point! ...)) : Polygon(cons(p0, p1, p2, ps))
  defrule shape! = (circle(?x:#double!, ?y:#double!, ?r:#non-neg-double!)) : Circle(Point(x,y),r)
  fail-if shape! = (circle(_ ...)) : ISE(closest-info(), "Circle expression expects three double arguments.")
  defrule shape! = (rectangle(?w:#non-neg-double!, ?h:#non-neg-double!)) : Rectangle(w, h, loc(0.0, 0.0))
  fail-if shape! = (rectangle(_ ...)) : ISE(closest-info(), "Rectangle expression expects two doubles.")
  fail-if shape! = () : ISE(closest-info(), "Expected a shape here.")

  defproduction point! : Point
  defrule point! = (point(?x:#double!, ?y:#double!)) : Point(x,y)
  fail-if point! = () : ISE(closest-info(), "Expected a point expression here.")

;============================================================
;===================== Errors ===============================
;============================================================

defn PList (info:False|FileInfo, ps:Collection<Property>, vs:List<KeyValue<Symbol,?>>, complete?:True|False) :
  try : PropertyList(ps, vs, complete?)
  catch (e:MissingProperty) :
    throw(ISE(info, "Missing %_ specifier." % [name(e)]))
  catch (e:DuplicateProperty) :
    throw(ISE(info, "Duplicate %_ specifier." % [name(e)]))
  catch (e:UnknownProperty) :
    throw(ISE(info, "Unsupported specifier: '%_'." % [name(e)]))

defn PList (info:False|FileInfo, ps:Collection<Property>, vs:List<KeyValue<Symbol,?>>) :
  PList(info, ps, vs, true)

public defstruct InputSpecError <: Exception :
  info: FileInfo|False
  msg
with :
  constructor => ISE
defmethod print (o:OutputStream, e:InputSpecError) :
  val info-string = match(info(e)) :
    (i:FileInfo) : "%_: " % [i]
    (i:False) : ""
  print(o, "%_%_" % [info-string, msg(e)])

