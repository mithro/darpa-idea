defpackage system-generator :
  import core
  import collections
  import input-spec/ir
  import rtm/ir
  import rtm/ir-gen
  import rtm/ir-utils
  import jitpcb/flags
  import interfaces
  import components
  import modules
  import peripherals
  import power-system-gen
  import powergen
  import modulegen

#use-added-syntax(ir-gen)

defn inst-place-peripherals (peripherals:List<Peripheral>, interfaces:HashTable<Symbol, Vector<Ref>>) :
  val per-count = to-seq(0 to false)  
  inside pcb-module :
    for per-def in peripherals do :
      if not flag?("preview") or pose(per-def) is-not False :
        val per-inst = generate-peripheral(per-def)
        val per-name = Ref("per-sg-%_" % [next(per-count)])
        ;MAKE LOAD HERE
        ;layout-group(anchor-ref(per-inst)) = {per-name}
        ;if not flag?("no-sch") :
        ;  schematic-group(anchor-ref(per-inst)) = {per-name}
      
        for e in intf-map(per-inst) do :
          add-all(interfaces[key(e)], value(e))
      
public defstruct ConnectorMapping :
  capability : Symbol ; Capability type
  pin-type : Symbol ; Pin type
  pin-map : Ref|List<[Ref,Ref]> ; pin mapping

defn ConnectorMapping (cap:Symbol, ref:Ref) : ConnectorMapping(cap, `pin, ref)

defn connector-table (connector:Connector) :
  val conn-table = HashTable<Symbol, ConnectorMapping>()
  val intf-idx = to-seq(0 to false)

  for intf in interfaces(connector) do :
    val intf-name = to-symbol("%_-%_" % [name(intf), next(intf-idx)])
    match(mapping(intf)) :
      
      (cs : CSinglePin) :
        conn-table[intf-name] = ConnectorMapping(name(intf), ref(cs))

      ; TODO: Make this actually work for arrays
      (ca : CArray) :
        conn-table[intf-name] = ConnectorMapping(name(intf), `pin-array, ref(pins(ca)[0] as CSinglePin))
      
      (cb : CBundle) :
        val ref-pair-list = to-list $
          for e in entries(cb) seq :
            [Ref(key(e)), ref(value(e) as CSinglePin)]

        conn-table[intf-name] = ConnectorMapping(name(intf), CAPABILITY-TABLE[name(intf)], ref-pair-list)

  conn-table

defn print-connector-table (c-table:HashTable<Symbol,ConnectorMapping>) :
  for k in keys(c-table) do :
    val cmap = c-table[k]
    println("%_:%_:%_:%_" % [k, capability(cmap), pin-type(cmap), pin-map(cmap)])

val STATIC-CONN-NPIN = HashTable<String, Int>()
STATIC-CONN-NPIN["micro-USB"] = 5
STATIC-CONN-NPIN["CR2450"] = 6
STATIC-CONN-NPIN["XT-60-pass"] = 2
STATIC-CONN-NPIN["barrel-jack"] = 2
STATIC-CONN-NPIN["phoenix-combicon-ptsm-8"] = 8
STATIC-CONN-NPIN["phoenix-combicon-ptsm-6"] = 6

defstruct ConnectorResult :
  pos-ref:Ref with: (setter => set-pos-ref, init => void)
  neg-ref:Ref with: (setter => set-neg-ref, init => void)
  source-voltage:Double with: (setter => set-source-voltage, init => void)
with :
  printer => true

defn has-interface? (c:Connector, int-name:Symbol) -> True|False :
  for interface in interfaces(c) any? :
    name(interface) == int-name

defn get-interface-pins (c:Connector, int-name:Symbol) -> CPins :
  for interface in interfaces(c) first! :
    if name(interface) == int-name : One(mapping(interface))
    else : None()

defn bundle-ref (c:CBundle, name:Symbol) -> Ref :
  ref(lookup(entries(c), name) as CSinglePin)

defn def-inst-place-connectors (connectors:List<Connector>, interfaces:HashTable<Symbol, Vector<Ref>>) :
  val result = ConnectorResult()
  inside pcb-module :
    val conn-counter = to-seq(0 to false)
    for conn in connectors do :
      if not flag?("preview") or pose(conn) is-not False :
        val conn-table = connector-table(conn)
        val conn-config = to-hashtable<Symbol,?>(config(conn))

        ; Determine type of connector 
        val name-str = to-string(name(conn))
        val conn-gen = if prefix?(name-str, "phoenix-combicon-mc") :
          phoenix-combicon-mc-cmp
        else if prefix?(name-str, "molex-pico-clasp") :
          molex-pico-clasp-cmp
        else if prefix?(name-str, "JST-PH") :
          JST-PH-cmp
        else if prefix?(name-str, "d-sub") :
          amphenol-delta-d-cmp
        else if prefix?(name-str, "pin-header") :
          if prefix?(name-str, "pin-header-2R") :
            pin-header-cmp{_,2}
          else :
            pin-header-cmp
        else if prefix?(name-str, "XT-60-pass") :
          Ref(`conn-wrapper-XT-60-pass)
        else if prefix?(name-str, "barrel-jack") :
          Ref(`cui-pj-202bh-cmp)
        else if prefix?(name-str, "phoenix-combicon-ptsm-8") :
          Ref(`phoenix-1778683-cmp)
        else if prefix?(name-str, "phoenix-combicon-ptsm-6") :
          Ref(`phoenix-1778803-cmp)
        else if prefix?(name-str, "micro-USB") :
          Ref(`conn-wrapper-micro-USB)
        else if prefix?(name-str, "CR2450") :
          Ref(`conn-wrapper-CR2450)
        else :
          fatal("Unrecognized connector type %_." % [name(conn)])

        ; Determine number of pins in connector
        val n-pins = if key?(STATIC-CONN-NPIN, name-str) :
          STATIC-CONN-NPIN[name-str]
        else :
          if key?(conn-config,`n-pins) :
            conn-config[`n-pins] as Int

          else :
            fatal("Cannot determine number of pins for connector type %_." % [name(conn)])
              
        ; Check number of requested pins is less than connector pins
        val n-req-pins = sum $
          for e in conn-table seq :
            match(pin-map(value(e))) :
              (r:Ref) : 1
              (rs:List) : length(rs)
        
        if n-req-pins > n-pins :
          fatal("Number of requested pins %_ greater than specified pins for %_." % [n-req-pins, n-pins])

        ; TODO: make sure max pin reference index is less than number of pins

        ; TODO: check for duplicate references, disallow?

        val name-root = "conn-%_-%_" % [name(conn), next(conn-counter)]
        val mod-ref = Ref(name-root)
        val inst-ref = Ref("%_-inst" % [name-root])

        if has-interface?(conn, `power-source) :
          set-source-voltage(result, conn-config[`source-voltage] as Double)
          val power-pins = get-interface-pins(conn, `power-source) as CBundle
          set-pos-ref(result, inst-ref.conn.{bundle-ref(power-pins, `pos)})
          set-neg-ref(result, inst-ref.conn.{bundle-ref(power-pins, `neg)})

        if has-interface?(conn, `power) :
          val power-pins = get-interface-pins(conn, `power) as CBundle
          within (rail) = make-load(conn-config[`voltage], conn-config[`current], 20.0e-3) :
            net - (pos(rail), inst-ref.conn.{bundle-ref(power-pins, `pos)})
            net - (neg(rail), inst-ref.conn.{bundle-ref(power-pins, `neg)})
            ;max-current-draw(inst-ref.conn.{bundle-ref(power-pins, `pos)}) = conn-config[`current]

        ; Define module with interface connections
        pcb-module {mod-ref} :
          val component = match(conn-gen) :
            (r: Ref) : r
            (g: (Int) -> Ref) : g(n-pins) 
          inst conn : {component}
          
          for e in conn-table do :
            val [intf, conn-map] = [Ref(key(e)), value(e)]
            match(pin-map(conn-map)) :
              (pin-ref:Ref) :
                pin {intf}
                net - (intf, conn.{pin-ref})
              (pin-map:List) :
                port {intf} : {Ref(pin-type(conn-map))}
                for [intf-pin, conn-pin] in pin-map do :
                  net - (intf.{intf-pin}, conn.{conn-pin})
        
        ; Instantiate and place connector module
        inst {inst-ref} : {mod-ref}
                
        ; Add connector instance interfaces to global table
        for e in conn-table do :
          if (capability(value(e)) != `power-source and capability(value(e)) != `power) :
            add(interfaces[capability(value(e))], inst-ref.{Ref(key(e))})
  result

defn inst-place-connect-i2c (interfaces: HashTable<Symbol, Vector<Ref>>) :
  if length(interfaces[`i2c]) > 0 :
    inside pcb-module :
      inst i2c-bus-inst : i2c-bus

      for sink in interfaces[`i2c] do :
        net - (i2c-bus-inst.dst-i2c, sink)

      within (rail) = make-load("I2C", 3.3, 1.5e-3, 50.0e-3) :
        net - (neg(rail) i2c-bus-inst.src-3v3.neg)
        net - (pos(rail) i2c-bus-inst.src-3v3.pos)
      
      interfaces[`i2c] = to-vector<Ref>([i2c-bus-inst.src-i2c])

defn inst-place-connect-busses (interfaces:HashTable<Symbol, Vector<Ref>>) :
  inst-place-connect-i2c(interfaces)

defn print-interfaces (interfaces:HashTable<Symbol, Vector<Ref>>) :
  for e in interfaces do :
    println("%_:" % [key(e)])
      for v in value(e) do :
        println("  %_" % [v])

defstruct LimitFailure :
  proc : Symbol
  intf : Symbol
  max : Int
  req : Int

defmethod print (o:OutputStream, e:LimitFailure) :
  print(o, "%_ requested %_ > %_ max %_ on %_" % [req(e) intf(e) max(e) proc(e)])

defstruct Proc :
  family : Symbol
  name : Symbol
  num-pins : Int
  instantiate : HashTable<Symbol,Vector<Ref>> -> ProcInstance
  limits : Tuple<KeyValue<Symbol, Int>>

defmethod print (o:OutputStream, p:Proc) :
  print(o, "Proc(family=%_ name=%_ num-pins=%_ limits=%_)" % [family(p), name(p), num-pins(p), limits(p)])

defn check-limits (proc:Proc, intf-req:HashTable<Symbol,Int>) -> Seq<LimitFailure> :
  generate<LimitFailure> :
    val max-intfs = to-hashtable<Symbol,Int> $ limits(proc)
    for intf in cat(keys(intf-req), keys(max-intfs)) do :
      if get?(intf-req, intf, 0) > get?(max-intfs, intf, 0) :
        yield(LimitFailure(name(proc), intf, get?(max-intfs, intf, 0), intf-req[intf]))

deftype ProcInstance
defmulti component (p:ProcInstance) -> Ref
defmulti wire (p:ProcInstance) 

defn count-interfaces (interfaces:HashTable<Symbol, Vector<Ref>>) -> HashTable<Symbol,Int> :
  val n-intfs = HashTable-init<Symbol,Int>({0})
  for intf in [`uart `can `swd `adc `dio `pwm `spi `i2c] do :
    n-intfs[intf] = length(interfaces[intf])
  n-intfs


val *procs* = Vector<Proc>()

deftype PiHat <: ProcInstance
defn PiHat (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : raspi-3B+-cmp
      require dio   : dio[n-intfs[`dio]] from proc
      require uart  : uart[n-intfs[`uart]] from proc
      require spi   : spi[n-intfs[`spi]] from proc
      require i2c   : i2c[n-intfs[`i2c]] from proc
      proc
  new PiHat :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        within (rail) = make-load("RasPi", 5.0, 2.0, 150.0e-3) :
          net gnd (proc-inst.gnd[2], neg(rail))
          net pow-5v0 (proc-inst.p5v0[0], proc-inst.p5v0[1], pos(rail))
        for i in 3 to 8 do :
          net - (proc-inst.gnd[2], proc-inst.gnd[i])
        ;net pow-3v3_pos (proc-inst.dst-3v3.pos, proc-inst.p3v3[1])

add(*procs*, Proc(`pi, `RasPi3B+, 40, PiHat, [
      `uart => 1
      `dio => 33
      `spi => 1
      `i2c => 1
    ]))

deftype Arduino <: ProcInstance
defn Arduino (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : arduino-pro-mini-cmp 
      require src-5v0 : power-5v0 from proc
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require reset : reset[n-intfs[`reset]] from proc
      require ext-int : ext-int[n-intfs[`ext-int]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new Arduino :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        within (rail) = make-load("Arduino", 5.0, 0.1, 150.0e-3) :
          net gnd (proc-inst.gnd[0], proc-inst.gnd[1], proc-inst.gnd[2], neg(rail))
          net pow-5v0 (proc-inst.src-5v0, pos(rail))

add(*procs*, Proc(`arduino, `arduino, 32, Arduino, [
      `uart => 1
      `adc => 6
      `dio => 21
      `reset => 1
      `ext-int => 2
      `spi => 1
      `i2c => 1
    ]))

deftype CSR <: ProcInstance
defn CSR (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : csr-CSR1010A05-IQQM-R-cmp
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require pwm : pwm[n-intfs[`pwm]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new CSR :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        pcb-module dummy-power :
          port pwr-3v3 : power
          port pwr-3v0 : power
        inst d-p : dummy-power
        inst x32 : epson-MC-146-cmp
        inst x16 : epson-TSX-3225-cmp
        inst ant : ant-2GHz4-inverted-f-cmp
        ;package(ant) on Top
        inst c2  : {murata-cap-cmp(0.0000005)}
        inst c3  : {murata-cap-cmp(0.470)}
        inst c4  : {murata-cap-cmp(0.470)}
        inst c7  : {murata-cap-cmp(0.470)}
        inst c9  : {murata-cap-cmp(0.470)}
        inst c5  : {murata-cap-cmp(4.7)}
        inst c17 : {murata-cap-cmp(4.7)}
        inst c6  : {murata-cap-cmp(0.000033)}
        inst c8  : {murata-cap-cmp(0.15)}
        inst c11 : {murata-cap-cmp(0.000010)}
        inst c12 : {murata-cap-cmp(0.000010)}
        inst c15 : {murata-cap-cmp(0.0000082)}
        inst c16 : {murata-cap-cmp(0.000015)}
        inst l2 : tdk-fb-1k5-cmp
        inst l3 : murata-ind-4uh7-cmp
        inst r3 : {gen-res-cmp(68000.0)}
        add(interfaces[`power-3v3], d-p.pwr-3v3)
        add(interfaces[`power-3v0], d-p.pwr-3v0)
        ; Power
        net gnd (d-p.pwr-3v3.neg, d-p.pwr-3v0.neg, proc-inst.vss, x16.g[0], x16.g[1], x32.g[0], x32.g[1], ant.gnd, 
                 c3.p[1], c5.p[1], c6.p[1], c8.p[1], c17.p[1], c4.p[1], c9.p[1], 
                 c2.p[1], c11.p[1], c12.p[1], c15.p[1], c16.p[1], r3.p[1], x32.g[0], 
                 x32.g[1], x16.g[0], x16.g[1])
        net - (d-p.pwr-3v3.pos, c3.p[0], proc-inst.vdd-pads)
       ;short-trace(c3.p[0], proc-inst.vdd-pads)
        net - (proc-inst.vdd-reg-in, c4.p[0], l3.p[1], c5.p[0])
        ;short-trace(l3.p[1], c4.p[0])
        ;short-trace(c4.p[0], c5.p[0])
        net - (proc-inst.smps-lx l3.p[0])
        ;short-trace(proc-inst.smps-lx l3.p[0])
        net - (c9.p[0], c8.p[0], proc-inst.vdd-core0, proc-inst.vdd-core1)
        ;short-trace(c8.p[0], c9.p[0])
        ;short-trace(c8.p[0], proc-inst.vdd-core0)
        net - (d-p.pwr-3v0.pos, l2.p[0], proc-inst.vdd-bat-smps, c17.p[0])
        net - (proc-inst.vdd-bat, l2.p[1], c6.p[0])
        ;short-trace(l2.p[0], c17.p[0])
        ;short-trace(l2.p[1], c6.p[0])
        ;short-trace(l2.p[1], proc-inst.vdd-bat)
        net - (proc-inst.vdd-xtal, c7.p[0])
        ;short-trace(proc-inst.vdd-xtal, c7.p[0])

        ; Oscillators 
        net - (x32.p[0], proc-inst.xtal-32k-out, c12.p[0])
        ;short-trace(proc-inst.xtal-32k-out, c12.p[0])
        ;short-trace(x32.p[0], c12.p[0])
        net - (x32.p[1], proc-inst.xtal-32k-in, c11.p[0])
        ;short-trace(proc-inst.xtal-32k-in, c11.p[0])
        ;short-trace(x32.p[1], c11.p[0])
        net - (x16.p[0], proc-inst.xtal-16M-out, c16.p[0])
        ;short-trace(x16.p[0], c16.p[0])
        ;short-trace(proc-inst.xtal-16M-out, c16.p[0])
        net - (x16.p[1], proc-inst.xtal-16M-in, c15.p[0])
        ;short-trace(x16.p[1], c15.p[0])
        ;short-trace(proc-inst.xtal-16M-in, c15.p[0])
        ; Antenna
        ;package(proc-inst) at loc(1.75, -5.0, -90.0) on Top (relative-to ant)
        net - (proc-inst.rf, ant.launch, c2.p[0])
        ;short-trace(ant.launch, c2.p[0])
        ;short-trace(proc-inst.rf, c2.p[0])

add(*procs*, Proc(`csr, `csr, 32, CSR, [
      `uart => 1
      `adc => 3
      `dio => 12
      `spi => 1
      `i2c => 1
      `pwm => 3 ; TODO: verify this
    ]))

deftype Nucleo <: ProcInstance
defn Nucleo (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : mbed-nucleo-cmp
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new Nucleo :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        within (rail) = make-load("Nucleo", 5.0, 0.1, 150.0e-3) :
          net gnd (proc-inst.gnd0, neg(rail))
          net pow-5v0 (proc-inst.src-5v0, pos(rail))
        
        ; TODO: replace this with input constraints on Nucleo side?
        ;package(proc-inst) on Bottom

add(*procs*, Proc(`nucleo, `nucleo, 32, Nucleo, [
      `uart => 1
      `adc => 9
      `dio => 20
      `spi => 1
      `i2c => 1
    ]))

deftype Electron <: ProcInstance
defn Electron (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : particle-electron-cmp 
      add-center-node("Particle Electron", 5.0, 2.0)
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new Electron :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        ; Represent that the gnd pins are wired together internally
        net gnd (proc-inst.gnd0, proc-inst.gnd1)
        within (rail) = make-load("Electron", 5.0, 2.0, 150.0e-3) :
          net gnd (proc-inst.gnd0, neg(rail))
          net pow-5v0 (proc-inst.vin, pos(rail))

add(*procs*, Proc(`electron, `electron, 32, Electron, [
      `uart => 3
      `adc => 12
      `dio => 28
      `spi => 2
      `i2c => 1
    ]))

deftype Teensy <: ProcInstance
defn Teensy (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : {pjrc-teensy-3-2-cmp(`side-pins)} 
      ;require dst-3v3 : power-3v3 from proc
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require can : can[n-intfs[`can]] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require pwm : pwm[n-intfs[`pwm]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new Teensy :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        pcb-module dummy-rail :
          port src-5v0 : power

        inst dr : dummy-rail
        
        net gnd (proc-inst.dst-3v3.neg, dr.src-5v0.neg)
        net - (proc-inst.vin, dr.src-5v0.pos)
        
        add(interfaces[`power-5v0], dr.src-5v0)
        ;add(interfaces[`power-3v3-source], proc-inst.dst-3v3)

add(*procs*, Proc(`teensy, `teensy, 32, Teensy, [
      `uart => 3
      `adc => 10
      `dio => 24
      `spi => 1
      `i2c => 1
      `can => 1
      `pwm => 6
    ]))

deftype TeensyInner <: ProcInstance
defn TeensyInner (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst = let :
    pcb-module proc-wrapper :
      port dst-3v3 : power
      port adc : pin[n-intfs[`adc]]
      port dio : pin[n-intfs[`dio]]
      port uart : uart[n-intfs[`uart]]
      port can : can[n-intfs[`can]]
      port spi : spi[n-intfs[`spi]]
      port pwm : pin[n-intfs[`pwm]]
      port i2c : i2c[2]
      port edio : pin[16]
      port iv-sense : iv-sense[18]

      inst proc : {pjrc-teensy-3-2-cmp(`inner-pins)} 
      ;require dst-3v3 : power-3v3 from proc
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require can : can[n-intfs[`can]] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require pwm : pwm[n-intfs[`pwm]] from proc
      require i2c : i2c[2] from proc

      inst i2cb-0 : i2c-bus
      inst i2cb-1 : i2c-bus

      inst pma-0 : {power-monitor-array(3)}
      inst pma-1 : {power-monitor-array(3)}

      inst eio : {digital-io-expander()}

      net - (proc.dst-3v3, i2cb-0.src-3v3, i2cb-1.src-3v3, pma-0.src-3v3, pma-1.src-3v3, eio.src-3v3)

      net i2c-0 (proc.i2c[0], i2cb-0.src-i2c, pma-0.i2c)
      net i2c-1 (proc.i2c[1], i2cb-1.src-i2c, pma-1.i2c, eio.i2c)

      for i in 0 to 9 do :
        net - (pma-0.iv-sense[i], iv-sense[i])
        net - (pma-1.iv-sense[i], iv-sense[i + 9])

      net - (eio.dio, edio)

      net - (proc.dst-3v3, dst-3v3)
      net - (proc.adc, adc)
      net - (proc.dio, dio)
      net - (proc.uart, uart)
      net - (proc.can, can)
      net - (proc.spi, spi)
      net - (proc.pwm, pwm)
      net - (proc.i2c, i2c)

    inside pcb-module :
      inst pw : proc-wrapper
      pw

  new TeensyInner :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        pcb-module dummy-rail :
          port src-5v0 : power

        inst dr : dummy-rail
        
        net gnd (proc-inst.dst-3v3.neg, dr.src-5v0.neg)
        net - (proc-inst.proc.vin, dr.src-5v0.pos)

        add(interfaces[`power-5v0], dr.src-5v0)
        ;add(interfaces[`power-3v3-source], proc-inst.dst-3v3)

add(*procs*, Proc(`teensy_inner, `teensy_inner, 32, TeensyInner, [
      `uart => 3
      `adc => 20
      `dio => 34
      `spi => 1
      `i2c => 2
      `can => 1
      `pwm => 10
    ]))

deftype TeensyAll <: ProcInstance
defn TeensyAll (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst = let :
    inside pcb-module :
      inst proc : {pjrc-teensy-3-2-cmp(`all-pins)} 
      ;require dst-3v3 : power-3v3 from proc
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require can : can[n-intfs[`can]] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require pwm : pwm[n-intfs[`pwm]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new TeensyAll :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      ;; TODO: THIS IS FROM TEENSY_INNER???
      inside pcb-module :
        pcb-module dummy-rail :
          port src-5v0 : power

        inst dr : dummy-rail
        
        net gnd (proc-inst.dst-3v3.neg, dr.src-5v0.neg)
        net - (proc-inst.proc.vin, dr.src-5v0.pos)

        add(interfaces[`power-5v0], dr.src-5v0)
        ;add(interfaces[`power-3v3-source], proc-inst.dst-3v3)

add(*procs*, Proc(`teensy_all, `teensy_all, 32, TeensyAll, [
      `uart => 3
      `adc => 21
      `dio => 24
      `spi => 1
      `i2c => 2
      `can => 1
      `pwm => 10
    ]))

deftype nRF52832 <: ProcInstance
defn nRF52832 (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : nordic-nRF52832-proc
      add-center-node("nRF52832", 3.3, 0.1)
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      ;require swd : swd[1] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new nRF52832 :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        inst tag : swd-tag-connect
        net - (proc-inst.proc.SWDCLK, tag.swd.swclk)
        net - (proc-inst.proc.SWDIO, tag.swd.swdio)

        within (rail) = make-load("nRF52832", 3.3, 0.1, 50.0e-3) :
          net gnd (proc-inst.pow3v0.neg neg(rail), tag.src-3v3.neg)
          net pow-3v3 (proc-inst.pow3v0.pos, pos(rail), tag.src-3v3.pos)

add(*procs*, Proc(`nrf, `nRF52832, 48, nRF52832, [
      `uart => 1
      `adc => 7
      `dio => 32
      `spi => 3
      `i2c => 2
      `pwm => 12
    ]))

deftype STM32F303K8T6 <: ProcInstance
defn STM32F303K8T6 (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : stmicro-STM32F303K8T6-cmp
      add-center-node("STM32F303K8T6", 3.3, 0.1)
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require can : can[n-intfs[`can]] from proc
      require swd : swd[1] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new STM32F303K8T6 :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        inst pd0 : {power-decouple()}
        inst pd1 : {power-decouple()}
        inst tag : swd-tag-connect
        net - (proc-inst.swd[0], tag.swd)

        net gnd (proc-inst.gnd0, proc-inst.gnd1)
        within (rail) = make-load("STM32F303K8T6", 3.3, 0.1, 50.0e-3) :
          net gnd (proc-inst.gnd0, proc-inst.gnd1, pd0.c0.p[0], pd1.c0.p[0], neg(rail), tag.src-3v3.neg)
          net pow-3v3 (proc-inst.vin0, pd1.c0.p[1], proc-inst.vin1, pd0.c0.p[1], pos(rail), tag.src-3v3.pos)
          ;short-trace(proc-inst.vin1, pd0.c0.p[1])
          ;short-trace(proc-inst.vin0, pd1.c0.p[1])

add(*procs*, Proc(`stm, `STM32F303K8T6, 32, STM32F303K8T6, [
      `uart => 3
      `adc => 12
      `dio => 28
      `spi => 2
      `pwm => 7
      `swd => 1
      `can => 1
      `i2c => 1
    ]))

deftype STM32L011D4 <: ProcInstance
defn STM32L011D4 (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : stmicro-STM32L011D4-cmp
      add-center-node("STM32L011D4", 3.3, 0.1)
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require swd : swd[1] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new STM32L011D4 :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        inst pd0 : {power-decouple()}
        inst tag : swd-tag-connect
        net - (proc-inst.swd[0], tag.swd)

        net gnd (proc-inst.vss)
        within (rail) = make-load("STM32L011D4", 3.3, 0.1, 50.0e-3) :
          net gnd (proc-inst.vss, pd0.c0.p[0], neg(rail), tag.src-3v3.neg)
          net pow-3v3 (proc-inst.vdd, pd0.c0.p[1], pos(rail), tag.src-3v3.pos)
          ;short-trace(proc-inst.vdd, pd0.c0.p[1])

add(*procs*, Proc(`stm, `STM32L011D4, 14, STM32L011D4, [
      `uart => 1
      `adc => 4
      `dio => 10
      `spi => 1
      `pwm => 3
      `swd => 1
      `i2c => 1
    ]))

deftype STM32F405RG <: ProcInstance
defn STM32F405RG (interfaces:HashTable<Symbol, Vector<Ref>>) :
  val n-intfs = count-interfaces(interfaces)
  val proc-inst =
    inside pcb-module :
      inst proc : stmicro-STM32F405RG-cmp
      add-center-node("STM32F405RG", 3.3, 0.1)
      require adc : adc[n-intfs[`adc]] from proc
      require dio : dio[n-intfs[`dio]] from proc
      require uart : uart[n-intfs[`uart]] from proc
      require swd : swd[1] from proc
      require spi : spi[n-intfs[`spi]] from proc
      require can : can[n-intfs[`can]] from proc
      require pwm : pwm[n-intfs[`pwm]] from proc
      require i2c : i2c[n-intfs[`i2c]] from proc
      proc
  new STM32F405RG :
    defmethod component (this) : proc-inst
    defmethod wire (this) :
      inside pcb-module :
        inst pd0 : {power-decouple()}
        inst pd1 : {power-decouple()}
        inst tag : swd-tag-connect

        within (rail) = make-load("STM32F405RG", 3.3, 0.1, 99.0e-3) :
          net gnd (proc-inst.VSS_1, neg(rail), tag.src-3v3.neg)
          net pow-3v3 (proc-inst.VDD_1, pos(rail), tag.src-3v3.pos)

        inst vcap-c-1 : {gen-cap-cmp(2.2)}
        inst vcap-c-2 : {gen-cap-cmp(2.2)}


        net gnd (proc-inst.VSS_1, proc-inst.VSS_2, proc-inst.VSSA, pd0.c0.p[0], pd1.c0.p[0], vcap-c-1.p[0], vcap-c-2.p[0])
        net - (proc-inst.VDD_1, proc-inst.VDD_2, proc-inst.VDD_3, proc-inst.VDD_4, proc-inst.VDDA, pd0.c0.p[1], pd1.c0.p[1])

        net vcap-1 (vcap-c-1.p[1], proc-inst.VCAP_1)
        net vcap-2 (vcap-c-2.p[1], proc-inst.VCAP_2)
        ;short-trace(proc-inst.VSS_1, pd0.c0.p[0])
        ;short-trace(proc-inst.VDD_1, pd0.c0.p[1])
        ;short-trace(proc-inst.VSSA, pd1.c0.p[0])
        ;short-trace(proc-inst.VDDA, pd1.c0.p[1])

        ; Oscillator

        inst osc-c-1 : {murata-cap-cmp(0.000027)}
        inst osc-c-2 : {murata-cap-cmp(0.000027)}

        inst xtal : ABM7-8MHZ-D2Y-T-cmp
        net - (pd0.c0.p[0] osc-c-1.p[0])
        net xtal-a (xtal.p[0] osc-c-1.p[1])

        net - (pd0.c0.p[0] osc-c-2.p[0])
        net xtal-b (xtal.p[1] osc-c-2.p[1])

        net - (xtal.p[0] proc-inst.PH0)
        net - (xtal.p[1] proc-inst.PH1)
        ;short-trace(xtal.p[0] proc-inst.PH0)
        ;short-trace(xtal.p[1] proc-inst.PH1)

        ; BOOT0
        inst BOOT0-r : {gen-res-cmp(47000.0)}
        net - (BOOT0-r.p[0] pd0.c0.p[0])
        net - (BOOT0-r.p[1] proc-inst.BOOT0)
        inst BOOT2-r : {gen-res-cmp(47000.0)}
        net - (BOOT2-r.p[0] pd0.c0.p[0])
        net - (BOOT2-r.p[1] proc-inst.b[2]) ; PB2 is BOOT2

        ; reset button
        ; values based off of https://www.st.com/en/evaluation-tools/stm32f4discovery.html
        inst reset-pullup : {gen-res-cmp(100000.0)}
        inst reset-cap : {gen-cap-cmp(0.1)}
        inst button : omron-B3U-1000P-cmp

        net - (proc-inst.swd[0], tag.swd)

        net - (proc-inst.swd[0].reset, button.p[1], reset-cap.p[1], reset-pullup.p[0])
        net - (button.p[0], proc-inst.VSS_1, reset-cap.p[0])
        net - (reset-pullup.p[1], proc-inst.VDD_1)

add(*procs*, Proc(`stm, `STM32F405RG, 64, STM32F405RG, [
        `uart => 6
        `adc => 16
        `dio => 51
        `can => 2
        `spi => 3
        `swd => 1
        `i2c => 3
        `pwm => 34
      ]))

defn choose-proc (n-intfs:HashTable<Symbol,Int>) -> Proc :
  val procs = to-tuple $ for proc in *procs* filter :
    flag?(to-string $ name(proc)) or flag?(to-string $ family(proc))
  println("MATCHED %_ PROCS" % [procs])
  if length(procs) == 0 :
    fatal("NO MATCHING PROCS")
  val sat-procs = to-tuple $ for proc in procs filter :
    empty?(check-limits(proc, n-intfs))
  println("SATISIFIED %_ PROCS" % [sat-procs])
  val sorted-procs = to-tuple $ lazy-qsort(num-pins, sat-procs)
  println("SORTED %_ PROCS" % [sorted-procs])
  if length(sorted-procs) == 0 :
    val failures = cat-all $ for proc in procs seq :
      check-limits(proc, n-intfs)
    fatal("LIMIT FAILURES %_" % [to-tuple $ failures])    
  else :
    to-tuple(sorted-procs)[0]

defn cfg-inst-place-proc (interfaces:HashTable<Symbol, Vector<Ref>>) :
  inside pcb-module :
    val proc = choose-proc(count-interfaces(interfaces))
    val proc-inst = instantiate(proc)(interfaces)
    wire(proc-inst)
    component(proc-inst)

defn connect-interfaces (proc-inst:Ref, interfaces:HashTable<Symbol, Vector<Ref>>) :
  inside pcb-module :
    
    val proc-uart-count = to-seq(0 to false)
    val proc-can-count = to-seq(0 to false)
    val proc-adc-count = to-seq(0 to false)
    val proc-dio-count = to-seq(0 to false)
    val proc-reset-count = to-seq(0 to false)
    val proc-ext-int-count = to-seq(0 to false)
    val proc-pwm-count = to-seq(0 to false)
    val proc-spi-count = to-seq(0 to false)
    val proc-swd-count = to-seq(0 to false)
    val proc-edio-count = to-seq(0 to false)
    val proc-iv-sense-count = to-seq(0 to false)

    for intf-type in keys(interfaces) do :
      for interface in interfaces[intf-type] do :
        switch(intf-type) :
          ; Capabilities
          `i2c :
            net i2c (proc-inst.i2c[0], interface)
          `can :
            val c-idx = next(proc-can-count)
            net can-mtx (proc-inst.can[c-idx].tx, interface.tx)
            net can-mrx (proc-inst.can[c-idx].rx, interface.rx)
          `uart :
            val u-idx = next(proc-uart-count)
            net uart-mtx (proc-inst.uart[u-idx].tx, interface.rx)
            net uart-mrx (proc-inst.uart[u-idx].rx, interface.tx)
          `swd :
            net swd (proc-inst.swd[next(proc-swd-count)], interface)
          `adc :
            net adc (proc-inst.adc[next(proc-adc-count)], interface)
          `dio :
            net dio (proc-inst.dio[next(proc-dio-count)], interface)      
          `reset :
            net reset (proc-inst.reset[next(proc-reset-count)], interface)              
          `ext-int :
            net ext-int (proc-inst.ext-int[next(proc-ext-int-count)], interface)
          `pwm :
            net pwm (proc-inst.pwm[next(proc-pwm-count)], interface)
          `spi :
            net spi (proc-inst.spi[next(proc-spi-count)], interface)
          ; Special case for Teensy with IO expander and power monitors
          `i2c-0 :
            net i2c-0 (proc-inst.i2c[0], interface)
          `i2c-1 :
            net i2c-1 (proc-inst.i2c[1], interface)
          `edio :
            net edio (proc-inst.edio[next(proc-edio-count)], interface)
          `iv-sense :
            net iv-sense (proc-inst.iv-sense[next(proc-iv-sense-count)], interface) 
          
          else :
            fatal("Unrecognized interface type %_" % [intf-type])

public defn generate-system (spec:InputSpec) :

  ;===============
  ; Initialize list of requested signal and power interfaces
  val interfaces = HashTable-init<Symbol, Vector<Ref>>(Vector<Ref>{})
  ;val interfaces = HashTable<Symbol, Vector<Ref>>()
  ;for t in keys(CAPABILITY-TABLE) do :
  ;  interfaces[t] = Vector<Ref>()
  
  ; Special case for power signals from power instance to 
  ;interfaces[`power-signals] = Vector<Ref>()

  val [board-boundary-geom, signal-boundary-geom] = match(board-shape(spec)) :
    ;TODO: offset signal boundary inward from board boundary by 0.3-0.6mm
    (s: Shape) : [s, s]
    (f: False) :
      val inf-rect = rectangle(DOUBLE-POSITIVE-INFINITY, DOUBLE-POSITIVE-INFINITY)
      [inf-rect, inf-rect]

  val sys-ref = Ref(name(spec))
  pcb-module {sys-ref} :

    ;generate-power-system(18.0, 75.0, Ref("BATTERY-POS"), Ref("BATTERY-NEG"))
    
    ; Instantiate and place peripherals
    inst-place-peripherals(peripherals(spec), interfaces)
   
    ;println("====== Peripherals Instantiated ======\n")
    ;print-interfaces(interfaces)

    ; Define, instantiate, and place connectors
    val con-result = def-inst-place-connectors(connectors(spec), interfaces)
    ;println("\n====== Connectors Instantiated ======\n")
    ;print-interfaces(interfaces)
    
    if not flag?("preview") :
      ; Instantiate busses and consolidate interfaces
      inst-place-connect-busses(interfaces)
      
      ;println("\n====== Busses Instantiated ======\n")
      ;print-interfaces(interfaces)
    
      ; Configure, instantiate, and place processor
      val proc-inst = cfg-inst-place-proc(interfaces)
      
      ;layout-group(proc-inst) = sg-proc
      ;if not flag?("no-sch") :
      ;  schematic-group(proc-inst) = sg-proc

      ;println("\n====== Proc Instantiated ======\n")
      ;print-interfaces(interfaces)
    
      ; Instantiate power distribution based on peripheral needs
      net pow-vin (pos-ref(con-result))
      val input-rail = generate-power-system(source-voltage(con-result), 75.0, neg-ref(con-result), pos-ref(con-result))
      ;max-current-draw(pos-ref(con-result)) = current(input-rail)
      ;max-current-draw(neg-ref(con-result)) = current(input-rail)
      
      ;layout-group(power-inst) = sg-power
      ;if not flag?("no-sch") :
      ;  schematic-group(power-inst) = sg-power
      
      ;println("\n====== Power Instantiated ======\n")
      ;print-interfaces(interfaces)
    
      ; Connect requested interfaces to processor and power
      connect-interfaces(proc-inst, interfaces)

      ; Define power and ground planes
      ;geom(Ref("gnd")) :
      ;  plane(isolate = 0.3) on layer(1) = signal-boundary-geom
      ;geom(Ref("pow-3v3")) :
      ; plane(isolate = 0.3) on layer(2) = signal-boundary-geom

  if not flag?("no-brd") :
    ;pcb-board system-board : 
    ;  stackup = bay-area-circuits-4-layer-62-mil
    ;  if board-shape(spec) is-not False :
    ;    boundary = board-boundary-geom
    ;    signal-boundary = signal-boundary-geom

    make-board({sys-ref})
      ;board = system-board
      ;rules = bay-area-circuits-std-rules
  
  ;if not flag?("no-sch") :
  ;  make-schematic({sys-ref})

defn main () :
  val filename = if flag?("input") :
    match(flag("input")) : 
      (s: String) : s
      (t: True|False) : "system.i"
  else :
    "system.i"
  val spec = parse-input-spec(filename)
  generate-system(spec)

main()
