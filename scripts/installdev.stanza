defpackage installdev :
  import core
  import collections
  import reader

;============================================================
;=============== Project File Definition ====================
;============================================================

defstruct ProjFile :
  macro-files: Tuple<String>
  stanza-files: Tuple<String>
  external-files: Tuple<String>
  linker-flags: Tuple<KeyValue<Symbol,String>>
  compiler-commands: Tuple<KeyValue<Symbol, Tuple<FileAssoc>>>
  core: Target
  plugins: Tuple<Plugin>
  output-files: Table<String,String> with: (init => HashTable<String,String>())
with :
  printer => true

deftype FileAssoc
defmulti command (a:FileAssoc) -> String
defstruct SuffixAssoc <: FileAssoc :
  suffix: String
  command: String with: (as-method => true)
with :
  printer => true
defstruct ListAssoc <: FileAssoc :
  files: Tuple<String>
  command: String with: (as-method => true)
with :
  printer => true
  
defstruct Target :
  package: Symbol
  stanza-files: Tuple<String>
  external-files: Tuple<String>
  linker-flags: Tuple<KeyValue<Symbol,String>>  
with :
  printer => true

defstruct Plugin :
  name: Symbol
  target: Target
with :
  printer => true

;============================================================
;=============== Project File Syntax ========================
;============================================================

defsyntax projfile :
  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)
  
  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)  
 
  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : PFE(closest-info(), "String expected here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : PFE(closest-info(), "Symbol expected here.")

  defproduction platform! : Symbol
  defrule platform! = (os-x) : `os-x
  defrule platform! = (linux) : `linux
  fail-if platform! = () : PFE(closest-info(), "Invalid platform. Expected os-x/linux.")
  
  defproduction :!
  defrule :! = (:) : false
  fail-if :! = () : PFE(closest-info(), "Colon expected here.")
  
  defproduction LS!
  fail-if LS! = (?x) when unwrap-token(x) is-not List : PFE(closest-info(), "Expected a list here.")
  defrule LS! = () : false

  defproduction compiler-command! : String
  defrule compiler-command! = (?s:#string!) :
    defn contains? (x:String) : index-of-chars(s, x) is Int
    if not (contains?("{INPUT}") and contains?("{OUTPUT}")) :
      throw(PFE(closest-info(), "Not a valid compiler command: %~. Missing {INPUT} and {OUTPUT} placeholders." % [s]))
    s
  
  defproduction assoc! : FileAssoc
  defrule assoc! = (*. ?suffix:#symbol! #:! ?value:#compiler-command!) : SuffixAssoc(string-join(["." suffix]), value)
  defrule assoc! = ((?files:#string! ...) #:! ?value:#compiler-command!) : ListAssoc(to-tuple(files), value)
  fail-if assoc! = () : PFE(closest-info(), "Expected a compiler command here.")
  
  defproduction compile-entry! : KeyValue<Symbol,Tuple<FileAssoc>>
  defrule compile-entry! = (?platform:#platform! #:! #LS! (?xs:#assoc! ...)) : platform => to-tuple(xs)
  
  defproduction linker-flags : Tuple<KeyValue<Symbol,String>>
  defrule linker-flags = (linker-flags #:! #LS! (?es:#link-entry! ...)) : to-tuple(es)

  defproduction link-entry! : KeyValue<Symbol,String>
  defrule link-entry! = (?platform:#platform! #:! ?value:#string!) : platform => value
  
  defproduction external-files : Tuple<String>
  defrule external-files = (external-files #:! #LS! (?fs:#string! ...)) : to-tuple(fs)

  defproduction stanza-files : Tuple<String>
  defrule stanza-files = (stanza-files #:! #LS! (?fs:#string! ...)) : to-tuple(fs)
  
  defproduction target-entry! : KeyValue<Symbol,?>
  defrule target-entry! = (package #:! ?value:#symbol!) : `package => value
  defrule target-entry! = (?ef:#external-files) : `external-files => ef
  defrule target-entry! = (?sf:#stanza-files) : `stanza-files => sf
  defrule target-entry! = (?lf:#linker-flags) : `linker-flags => lf
  fail-if target-entry! = () : PFE(closest-info(), "Unrecognized target option.")
  
  defproduction target! : Target
  defrule target! = (#:! #LS! (?es:#target-entry! ...)) :
    defn entry (e:ParseEntry) : parse(closest-info(), es, e)
    Target(
      entry(RequiredEntry(`package, true))
      entry(OptionalEntry(`stanza-files, true, []))
      entry(OptionalEntry(`external-files, true, []))
      entry(OptionalEntry(`linker-flags, true, [])))

  defproduction top-entry! : KeyValue<Symbol,?>
  defrule top-entry! = (jitpcb plugin ?name:#symbol! ?t:#target!) :
    `plugin => Plugin(name, t)
  defrule top-entry! = (jitpcb core ?t:#target!) :
    `core => t
  fail-if top-entry! = (jitpcb) :
    PFE(closest-info(), "Invalid jitpcb target entry.")
  defrule top-entry! = (compiling #:! #LS! (?es:#compile-entry! ...)) :
    `compiling => to-tuple(es)
  defrule top-entry! = (?lf:#linker-flags) :
    `linker-flags => lf
  defrule top-entry! = (?sf:#stanza-files) :
    `stanza-files => sf
  defrule top-entry! = (?ef:#external-files) :
    `external-files => ef
  defrule top-entry! = (stanza-files #:! #LS! (?files:#string! ...)) :
    `stanza-files => to-tuple(files)
  defrule top-entry! = (macro-files #:! #LS! (?files:#string! ...)) :
    `macro-files => to-tuple(files)
  fail-if top-entry! = () :
    PFE(closest-info(), "Invalid top level command.")

  public defproduction projfile! : ProjFile
  defrule projfile! = (?es:#top-entry! ...) :
    defn entry (e:ParseEntry) : parse(closest-info(), es, e)
    val pj = ProjFile(
      entry(OptionalEntry(`macro-files, true, []))
      entry(RequiredEntry(`stanza-files, true))
      entry(OptionalEntry(`external-files, true, []))
      entry(OptionalEntry(`linker-flags, true, []))
      entry(OptionalEntry(`compiling, true, []))
      entry(RequiredEntry(`core, true))
      to-tuple(entry(OptionalListEntry(`plugin))))
    compute-output-files(pj)
    pj

;============================================================
;======================= Error ==============================
;============================================================

defstruct ProjFileError <: Exception :
  info: FileInfo|False
  msg
with :
  constructor => PFE
defmethod print (o:OutputStream, e:ProjFileError) :
  val info-str = ("%_: " % [info(e)]) when info(e) is FileInfo
            else ""
  print(o, "%_%_" % [info-str, msg(e)])

;============================================================
;==================== Entry Parsing =========================
;============================================================

deftype ParseEntry
defmulti name (p:ParseEntry) -> Symbol
defmulti unique? (p:ParseEntry) -> True|False

defstruct RequiredEntry <: ParseEntry :
  name: Symbol with: (as-method => true)
  unique?: True|False with: (as-method => true)
defstruct OptionalEntry <: ParseEntry :
  name: Symbol with: (as-method => true)
  unique?: True|False with: (as-method => true)
  default: ?
defn OptionalListEntry (name:Symbol) :
  OptionalEntry(name, false, List())

defn parse (info:FileInfo|False, es:List<KeyValue<Symbol,?>>, entry:ParseEntry) -> ? :
  val num = count({key(_) == name(entry)}, es)
  if num > 0 :
    if unique?(entry) :
      throw(PFE(info, "Duplicate %_ entry." % [name(entry)])) when num > 1
      lookup(es, name(entry))
    else :
      to-list(seq(value, filter({key(_) == name(entry)}, es)))
  else :
    match(entry) :
      (entry:RequiredEntry) : throw(PFE(info, "Missing %_ entry." % [name(entry)]))
      (entry:OptionalEntry) : default(entry)

;============================================================
;============== Initialize the Directory ====================
;============================================================

defn setup-directory () :
  val release-root = request-jitpcb-release()

  ;Create a fresh folder
  println("Setting up dev directory.")
  sys $ ["rm" "-rf" "dev"] ;Delete existing folder
  sys $ ["mkdir" "dev"]    ;Create a new folder

  ;Copy over necessary files
  val pwd = resolve-path(".") as String
  defn copy-stz (name:String) :
    val folder = string-join $ [release-root "/" name]
    sys $ ["cp" "-r" folder "dev"]
  defn link-stz (name:String) :
    sys $ ["ln" "-s" string-join([pwd "/" name]) "dev"]
  
  copy-stz("License.txt")
  copy-stz("runtime")
  copy-stz("pkgs")
  copy-stz("fast-pkgs")
  copy-stz("fplugins")
  copy-stz("jitpcb")
  copy-stz("jitpcb-debug")
  link-stz("jitpcb.params")
  link-stz("scripts")

  ;Create symbolic link  
  sys $ ["ln" "-s" string-join([pwd "/dev/fplugins"]) "dev/plugins"]

;============================================================
;============== Compile Bootstrap Compiler ==================
;============================================================

defn build-bootstrap-compiler (pj:ProjFile) :
  if request-build-bootstrap() :
    println("Building bootstrap compiler.")
    sys $ ["stanza"
           macro-files(pj)
           "stz/driver"
           "-o" "jstanza"         
           "-ccfiles" "runtime/rtm-utils.c"
           "-optimize"]

;============================================================
;================ Compile Auxiliary Files ===================
;============================================================

defn compile-ex-files (pj:ProjFile, platform:Symbol) :
  println("Building external files")
  for file in externally-compiled-files(pj) do :
    val comm-template = compilation-command(pj, platform, file)
    val output = external-file-output-name(pj, file)
    val comm = replace-template(comm-template, [
      "{INPUT}" => file
      "{OUTPUT}" => append("dev/" output)])
    println(comm)
    sys $ ["sh" "-c" comm]

;============================================================
;================ Create the .jitpcb file ===================
;============================================================

defn make-jitpcb-file () :
  val pwd = resolve-path(".") as String
  val file = replace-template(JITPCB-FILE, ["{ROOT}" => pwd])
  spit("dev/.jitpcb", file)
val JITPCB-FILE = trim $ \<S>
install-dir = "{ROOT}/dev"
<S>

;============================================================
;================ Create .stanza file =======================
;============================================================

defn make-stanza-file (platform:Symbol) :
  val pwd = resolve-path(".") as String
  val stanza-dir = sys-output $ ["stanza" "path"]
  val file = replace-template(STANZA-FILE, [
    "{STANZA}" => stanza-dir
    "{PLATFORM}" => to-string(platform)
    "{ROOT}" => pwd])
  spit("dev/.stanza", file)
val STANZA-FILE = trim $ \<S>
install-dir = "{STANZA}"
platform = {PLATFORM}
pkg-dirs = ("{ROOT}/dev/pkgs")
fast-pkg-dirs = ("{ROOT}/dev/fast-pkgs")
<S>

;============================================================
;============== Dependency Computation ======================
;============================================================

defn compile? (filename:String) :
  not suffix?(filename, ".c")

defn externally-compiled-files (pj:ProjFile) :
  keys(output-files(pj))

defn compilation-command (pj:ProjFile, platform:Symbol, file:String) :
  defn no-command () :
    throw(PFE(false, "No appropriate compilation command for compiling %~ on %_ platform." % [file, platform]))
  match(lookup?(compiler-commands(pj), platform)) :
    (assocs:Tuple<FileAssoc>) :
      val fassocs = filter(match?{_, file}, assocs)
      no-command() when empty?(fassocs)
      command(maximum(priority, fassocs))
    (f:False) :
      no-command()

defn match? (a:FileAssoc, file:String) :
  match(a) :
    (a:SuffixAssoc) : suffix?(file, suffix(a))
    (a:ListAssoc) : contains?(files(a), file)

defn priority (a:FileAssoc) :
  match(a) :
    (a:SuffixAssoc) : 0
    (a:ListAssoc) : 1
  
defn external-file-output-name (pj:ProjFile, file:String) :
  output-files(pj)[file]  

defn compute-output-files (pj:ProjFile) :
  ;Get list of all external files
  val all-external-files = unique $ cat-all $ [
    external-files(pj)
    external-files(core(pj))
    seq-cat(external-files{target(_)}, plugins(pj))]
    
  ;Compute a unique output filename
  defn unique-out-file (prefix:String) :
    val ss = cat([string-join([prefix ".o"])],
                 seq(string-join{[prefix _ ".o"]}, 0 to false))
    find!({not key?(output-files(pj), _)}, ss)

  ;Assign a unique output filename to all external files that will
  ;be compiled
  for f in all-external-files do :
    if compile?(f) :
      output-files(pj)[f] = unique-out-file(strip-filename(f))

defn compute-cc-files (pj:ProjFile, t:Target) :
  val files = unique(cat(external-files(pj), external-files(t)))
  for f in files map :
    if not compile?(f) : relative-to-dev(f)
    else : output-files(pj)[f]

defn compute-stanza-files (pj:ProjFile, t:Target) :
  val files = unique(cat(stanza-files(pj), stanza-files(t)))
  map(relative-to-dev, files)

defn all-stanza-files (pj:ProjFile) :
  val files = unique $ generate<String> :
    do(yield, stanza-files(pj))
    defn scan (t:Target) : do(yield, stanza-files(t))
    scan(core(pj))
    do(scan{target(_)}, plugins(pj))
  map(relative-to-dev, files)

defn compute-cc-flags (pj:ProjFile, t:Target, platform:Symbol, plugin?:True|False) :
  val flags = Vector<String>()
  defn add? (flag:String|False) :
    match(flag:String) : add(flags, flag)
  add?(linker-flags(pj, platform))
  add?(linker-flags(t, platform))
  add?("-shared") when plugin?  
  string-join(flags, " ")

defn linker-flags (pj:ProjFile, platform:Symbol) :
  lookup?(linker-flags(pj), platform)
defn linker-flags (t:Target, platform:Symbol) :
  lookup?(linker-flags(t), platform)

;============================================================
;================ Create .build file ========================
;============================================================

defn make-build-file (pj:ProjFile, platform:Symbol) :
  val o = StringBuffer()
  ;Generate core target
  let :
    val filled = replace-template(CORE-TARGET, [
      "{STZ-FILES}" => indented-strings(compute-stanza-files(pj, core(pj)),4)
      "{PACKAGE}" => to-string(package(core(pj)))
      "{CC-FILES}" => indented-strings(compute-cc-files(pj, core(pj)), 4)
      "{CC-FLAGS}" => compute-cc-flags(pj, core(pj), platform, false)])
    println(o, filled)
  ;Generate plugin targets
  for plugin in plugins(pj) do :
    val target = target(plugin)
    val filled = replace-template(PLUGIN-TARGET, [
      "{NAME}" => to-string(name(plugin))
      "{STZ-FILES}" => indented-strings(compute-stanza-files(pj, target),4)
      "{PACKAGE}" => to-string(package(target))
      "{CC-FILES}" => indented-strings(compute-cc-files(pj, target), 4)
      "{CC-FLAGS}" => compute-cc-flags(pj, target, platform, true)])
    println(o, filled)
    
  ;Generate file
  spit("dev/stanza.build", to-string(o))

val CORE-TARGET = trim $ \<S>
jitpcb :
  filenames: {STZ-FILES}
  link: ({PACKAGE})
  pkg: "fast-pkgs"
  o: "jitpcb"
  ccfiles: {CC-FILES}
  ccflags: "{CC-FLAGS}"
  optimize
jitpcb-debug :
  filenames: {STZ-FILES}
  link: ({PACKAGE})
  pkg: "pkgs"
  o: "jitpcb-debug"
  ccfiles: {CC-FILES}
  ccflags: "{CC-FLAGS}"
<S>

val PLUGIN-TARGET = trim $ \<S>
{NAME} :
  filenames: {STZ-FILES}
  link: ({PACKAGE})
  pkg: "pkgs"
  o: "fplugins/{NAME}.plugin"
  ccfiles: {CC-FILES}
  ccflags: "{CC-FLAGS}"
fast_{NAME} :
  filenames: {STZ-FILES}
  link: ({PACKAGE})
  pkg: "fast-pkgs"
  o: "fplugins/{NAME}.plugin"
  ccfiles: {CC-FILES}
  ccflags: "{CC-FLAGS}"
  optimize  
<S>

;============================================================
;================== Create make-all files ===================
;============================================================

defn make-make-all-files (pj:ProjFile) :
  val o = StringBuffer()
  val od = StringBuffer()
  ;Clean
  println(o, "stanza clean")
  println(od, "stanza clean")
  ;Build core
  println(o, "../jstanza build jitpcb")
  println(od, "../jstanza build jitpcb-debug")
  ;Build plugins
  for plugin in plugins(pj) do :
    println(o, "../jstanza build fast_%_" % [name(plugin)])
    println(od, "../jstanza build %_" % [name(plugin)])
  ;Spit out files
  spit("dev/make-all.sh", to-string(o))
  spit("dev/make-all-debug.sh", to-string(od))
  sys $ ["chmod" "+x" "dev/make-all.sh"]
  sys $ ["chmod" "+x" "dev/make-all-debug.sh"]

;============================================================
;================ Create devenv.sh file =====================
;============================================================

defn make-devenv-file () :
  val pwd = resolve-path(".") as String
  val file = replace-template(DEVENV-FILE, [
    "{ROOT}" => pwd])
  spit("dev/devenv.sh", file)
val DEVENV-FILE = trim $ \<S>
export JITPCB_CONFIG="{ROOT}/dev"
export STANZA_CONFIG="{ROOT}/dev"
export JITPCB_ROOT="{ROOT}/dev"
<S>

;============================================================
;============= Create make-jitpcb.sh file ===================
;============================================================
defn make-make-jitpcb-file (pj:ProjFile, platform:Symbol, cross-platform:Symbol|False) :
  val o = StringBuffer()
  val of = StringBuffer()
  defn P (msg) : println(o, msg)
  defn Pf (msg) : println(of, msg)

  ;==== Build folder ====
  defn build-folder (platform:Symbol) :
    switch(platform) :
      `os-x : "stage"
      `linux : "lstage"

  ;==== lfinish.sh ====
  val cross-compile? = cross-platform is Symbol
  defn cross-platform! () : cross-platform as Symbol
  if cross-compile? :
    Pf $ "STANZA=`stanza path`"

  ;==== make-jitpcb.sh ====
  ;Retrieve current folder
  P $ "ROOT=`pwd`"

  ;Declare files
  P $ \<S>FILES="%s"<S> % [all-stanza-files(pj)]

  ;Create and enter directory 
  P $ replace-template(MKDIR-FMT, ["{STAGE}" => build-folder(platform)])
  P $ "cd $ROOT/%_" % [build-folder(platform)]
  
  ;Compile auxiliary files
  P $ \<S>echo "Compiling auxiliary files"<S>
  for file in externally-compiled-files(pj) do :
    ;Retrieve the platform-specific compilation command
    defn comm-command (platform:Symbol) :
      val comm-template = compilation-command(pj, platform, file)
      val output = external-file-output-name(pj, file)
      replace-template(comm-template, [
        "{INPUT}" => relative-to-dev(file)
        "{OUTPUT}" => output])

    ;Write out platform compilation command
    P $ comm-command(platform)
    
    ;Write out cross compilation command
    if cross-compile? :
      Pf $ comm-command(cross-platform!())

  ;Compile pkg files
  P $ COMPILE-PKGS

  ;Compile core
  P $ \<S>echo "Compiling jitpcb-debug"<S>
  P $ replace-template(\<S>../jstanza {PACKAGE} -pkg pkgs -ccfiles {CCFILES} -ccflags "{CCFLAGS}" -o jitpcb-debug<S>, [
    "{PACKAGE}" => to-string(package(core(pj)))
    "{CCFILES}" => join-w-space(compute-cc-files(pj, core(pj)))
    "{CCFLAGS}" => compute-cc-flags(pj, core(pj), platform, false)])
    
  P $ \<S>echo "Compiling jitpcb"<S>
  P $ replace-template(\<S>../jstanza {PACKAGE} -pkg fast-pkgs -ccfiles {CCFILES} -ccflags "{CCFLAGS}" -o jitpcb -optimize<S>, [
    "{PACKAGE}" => to-string(package(core(pj)))
    "{CCFILES}" => join-w-space(compute-cc-files(pj, core(pj)))
    "{CCFLAGS}" => compute-cc-flags(pj, core(pj), platform, false)])

  ;Compile plugins
  for plugin in plugins(pj) do :
    val target = target(plugin)
    P $ replace-template(COMPILE-PLUGIN, [
      "{NAME}" => to-string(name(plugin))
      "{PACKAGE}" => to-string(package(target))
      "{CCFILES}" => join-w-space(compute-cc-files(pj, target))
      "{CCFLAGS}" => compute-cc-flags(pj, target, platform, true)])

  ;Cleanup
  P $ \<S>echo "Cleanup auxiliary files"<S>
  for file in externally-compiled-files(pj) do :
    P $ "rm %_" % [external-file-output-name(pj, file)]

  ;## Compile on cross platform ##
  if cross-compile? :
    ;Create and enter directory
    P $ replace-template(MKDIR-FMT, ["{STAGE}" => build-folder(cross-platform!())])
    P $ "cd $ROOT/%_" % [build-folder(cross-platform!())]

    ;Copy over .stanza and .finish scripts
    P $ "cp $ROOT/scripts/.lstanza .stanza"
    P $ "cp $ROOT/scripts/lfinish.sh finish.sh"

    ;Compile pkg files
    P $ COMPILE-PKGS

    ;Compile and Link core.s
    P $ \<S>echo "Compiling jitpcb-debug"<S>
    Pf $ \<S>echo "Linking jitpcb-debug"<S>
    P $ replace-template(\<S>../jstanza {PACKAGE} -pkg pkgs -s jitpcb-debug.s<S>, [
      "{PACKAGE}" => to-string(package(core(pj)))])
    Pf $ replace-template(\<S>gcc -std=gnu99 jitpcb-debug.s $STANZA/runtime/driver.c {CCFILES} -o jitpcb-debug -lm -D PLATFORM_LINUX {CCFLAGS}<S>, [
      "{CCFILES}" => join-w-space(compute-cc-files(pj, core(pj)))
      "{CCFLAGS}" => compute-cc-flags(pj, core(pj), cross-platform!(), false)])
      
    P $ \<S>echo "Compiling jitpcb"<S>
    Pf $ \<S>echo "Linking jitpcb"<S>
    P $ replace-template(\<S>../jstanza {PACKAGE} -pkg fast-pkgs -s jitpcb.s -optimize<S>, [
      "{PACKAGE}" => to-string(package(core(pj)))])
    Pf $ replace-template(\<S>gcc -std=gnu99 jitpcb.s $STANZA/runtime/driver.c {CCFILES} -o jitpcb -lm -D PLATFORM_LINUX {CCFLAGS}<S>, [
      "{CCFILES}" => join-w-space(compute-cc-files(pj, core(pj)))
      "{CCFLAGS}" => compute-cc-flags(pj, core(pj), cross-platform!(), false)])
    
    Pf $ "rm jitpcb-debug.s"
    Pf $ "rm jitpcb.s"

    ;Compile and Link plugins.s
    for plugin in plugins(pj) do :
      val target = target(plugin)
      P $ replace-template(COMPILE-PLUGIN-S, [
        "{NAME}" => to-string(name(plugin))
        "{PACKAGE}" => to-string(package(target))])  
      Pf $ replace-template(LINK-PLUGIN-S, [
        "{NAME}" => to-string(name(plugin))
        "{CCFILES}" => join-w-space(compute-cc-files(pj, target))
        "{CCFLAGS}" => compute-cc-flags(pj, target, cross-platform!(), true)])  

    ;Cleanup
    P $ "rm .stanza"

    ;Cleanup
    Pf $ \<S>echo "Cleanup auxiliary files"<S>
    for file in externally-compiled-files(pj) do :
      Pf $ "rm %_" % [external-file-output-name(pj, file)]
    Pf $ "rm finish.sh"

  ;Create files
  spit("scripts/make-jitpcb.sh", to-string(o))
  sys $ ["chmod" "+x" "scripts/make-jitpcb.sh"]

  if cross-compile? :
    spit("scripts/lfinish.sh", to-string(of))
    sys $ ["chmod" "+x" "scripts/lfinish.sh"]

val MKDIR-FMT = trim $ \<S>
cd $ROOT
rm -r {STAGE}
mkdir {STAGE}
mkdir {STAGE}/plugins
mkdir {STAGE}/fplugins
mkdir {STAGE}/pkgs
mkdir {STAGE}/fast-pkgs
cp -r runtime {STAGE}
cp -r scripts {STAGE}
cp License.txt {STAGE}
cp jitpcb.params {STAGE}
<S>

val COMPILE-PKGS = trim $ \<S>
echo "Compiling pkgs"
../jstanza $FILES -pkg pkgs
echo "Compiling fast-pkgs"
../jstanza $FILES -pkg fast-pkgs -optimize
<S>

val COMPILE-PLUGIN = trim $ \<S>
echo "Compiling {NAME} plugin"
../jstanza {PACKAGE} -pkg pkgs -ccfiles {CCFILES} -ccflags "{CCFLAGS}" -o plugins/{NAME}.plugin
../jstanza {PACKAGE} -pkg fast-pkgs -ccfiles {CCFILES} -ccflags "{CCFLAGS}" -optimize -o fplugins/{NAME}.plugin
<S>

val COMPILE-PLUGIN-S = trim $ \<S>
echo "Compiling {NAME} plugin"
../jstanza {PACKAGE} -pkg pkgs -s plugins/{NAME}.plugin.s
../jstanza {PACKAGE} -pkg fast-pkgs -optimize -s fplugins/{NAME}.plugin.s
<S>

val LINK-PLUGIN-S = trim $ \<S>
echo "Linking {NAME} plugin"
gcc -std=gnu99 plugins/{NAME}.plugin.s $STANZA/runtime/driver.c {CCFILES} -o plugins/{NAME}.plugin -lm -D PLATFORM_LINUX {CCFLAGS}
gcc -std=gnu99 fplugins/{NAME}.plugin.s $STANZA/runtime/driver.c {CCFILES} -o fplugins/{NAME}.plugin -lm -D PLATFORM_LINUX {CCFLAGS}
rm plugins/{NAME}.plugin.s
rm fplugins/{NAME}.plugin.s
<S>

;============================================================
;============= Create release file ==========================
;============================================================

defn make-release-file () :
  val release-dir = request-jitpcb-release()
  val filled = replace-template(RELEASE-FMT, [
    "{RELEASE}" => release-dir])
  spit("scripts/release-jitpcb.sh", filled)
  sys $ ["chmod" "+x" "scripts/release-jitpcb.sh"]

val RELEASE-FMT = trim $ \<S>
if [ $# -lt 2 ]; then
    echo "Not enough arguments: Expected osx/linux 0.0.1."
    exit 2
fi

DIR=`pwd`
if [ "$1" == "linux" ] || [ "$1" == "all" ]
then
  cd {RELEASE}
  git checkout linux
  rsync -avz --delete $DIR/lstage/ . --exclude=/.git
  git add -A
  git commit -m "version $2"
  git push
  cd $DIR
fi
if [ "$1" == "osx" ] || [ "$1" == "all" ]
then
  cd {RELEASE}
  git checkout osx
  rsync -avz --delete $DIR/stage/ . --exclude=/.git
  git add -A
  git commit -m "version $2"
  git push
  cd $DIR
fi
if [ "$1" == "linux-rc" ] || [ "$1" == "all-rc" ]
then
  cd {RELEASE}
  git checkout linux-rc
  rsync -avz --delete $DIR/lstage/ . --exclude=/.git
  git add -A
  git commit -m "version $2"
  git push
  cd $DIR
fi
if [ "$1" == "osx-rc" ] || [ "$1" == "all-rc" ]
then
  cd {RELEASE}
  git checkout osx-rc
  rsync -avz --delete $DIR/stage/ . --exclude=/.git
  git add -A
  git commit -m "version $2"
  git push
  cd $DIR
fi
<S>
  
;============================================================
;============= Create .lstanza file =========================
;============================================================

defn make-lstanza-file (platform:Symbol) :
  val stanza-dir = request-lstanza()
  val filled = replace-template(LSTANZA-FMT, [
    "{STANZA}" => stanza-dir
    "{PLATFORM}" => to-string(platform)])
  spit("scripts/.lstanza", filled)

val LSTANZA-FMT = trim $ \<S>
install-dir = "{STANZA}"
platform = {PLATFORM}
<S>  

;============================================================
;====================== Template Utility ====================
;============================================================

defn replace-template (template:String, fills:Seqable<KeyValue<String,String>>) :
  defn fill (t:String, e:KeyValue<String,String>) :
    replace(t, key(e), value(e))
  reduce(fill, template, fills)

;============================================================
;=================== User Requests ==========================
;============================================================

defn request-platform () :
  defn check-platform (s:String) :
    if not contains?(["os-x" "linux"], s) :
      to-string("Not a recognized platform: %_" % [s])
  to-symbol(request-prompt("System platform (os-x/linux): ", check-platform))

defn request-cross-platform () :
  defn check-platform (s:String) :
    switch(s) :
      "os-x" : "OS-X is not yet supported as a cross platform target."
      "linux" : false
      "none" : false
      else : to-string("Not a recognized platform: %_" % [s])
  val answer = request-prompt("Build for cross platform? (os-x/linux/none): ", check-platform)
  if answer == "none" : false
  else : to-symbol(answer)

defn request-jitpcb-release () :
  defn check-dir (s:String) :
    val license = norm-path("%_/License.txt" % [s])
    if not file-exists?(license) :
      to-string("Could not locate license file at %_." % [license])    
  request-prompt("Jitpcb release installation folder: ", check-dir)

defn request-lstanza () :
  defn check-dir (s:String) :
    val license = norm-path("%_/License.txt" % [s])
    if not file-exists?(license) :
      to-string("Could not locate license file at %_." % [license])
  request-prompt("Linux Stanza installation folder: ", check-dir)

defn request-bool (msg) :
  defn check-yes-no (s:String) :
    if not contains?(["yes" "no"], s) :
      "Please answer yes or no."
  val msg-str = string-join([msg " (yes/no): "])
  val answer = request-prompt(msg-str, check-yes-no)
  answer == "yes"  

defn request-build-bootstrap () :
  if file-exists?("jstanza") :
    request-bool("A bootstrap compiler already exists. Should we recompile it?")
  else : true

;============================================================
;=================== Utilities ==============================
;============================================================

;Request user for information
defn* request-prompt (prompt:String, check:String -> String|False) :
  print(prompt)
  val line = read-input-line()
  match(check(line)) :
    (r:False) :
      line
    (r:String) :
      println(r)
      request-prompt(prompt, check)

;Given a filename specified at jitpcb root,
;Return the file when referred to from the dev folder.
defn relative-to-dev (filename:String) :
  if prefix?(filename, "/") : filename
  else : append("../" filename)

;Strip filename
defn strip-filename (s:String) :
  val starti = match(last-index-of-char(s, '/')) :
    (i:Int) : i + 1
    (i:False) : 0
  val endi = match(last-index-of-char(s, '.')) :
    (i:Int) : length(s) when i <= starti else i
    (i:False) : length(s)
  fatal("Invalid filename: %~" % [s]) when endi <= starti
  s[starti to endi]

defn join-w-space (xs:Seqable<String>) :
  string-join(xs, " ")

;Return the sequence of strings, formatted as a Stanza list
;in a context expecting an indentation of n.
defn indented-strings (xs0:Seqable<String>, n:Int) :
  val xs = to-seq(xs0)
  if empty?(xs) :
    "()"
  else :
    val o = StringBuffer()
    val o2 = IndentedStream(o, n)
    for x in xs do :
      print(o2, "\n%~" % [x])
    to-string(o)  

;Return a flattened representation of everything in the tuple
defn flatten (args) :
  to-tuple $ generate<String> :
    let loop (x = args) :
      match(x) :
        (x:String) : yield(x)
        (x:Seqable) : do(loop, x)

;Flatten arguments and then call
defn sys (args0) :
  val args = flatten(args0)
  call-system(args[0], args)

;Flatten arguments, call, and return response
defn sys-output (args0) -> String :
  val args = flatten(args0)
  val p = Process(args[0], args, PROCESS-IN, PROCESS-OUT, PROCESS-OUT)
  trim(read-all(output-stream(p)))

;Read an input line
defn read-input-line () :
  val s = StringBuffer()
  let loop () :
    match(get-char(STANDARD-INPUT-STREAM)) :
      (c:Char) :
        if c != '\n' :
          add(s, c)
          loop()
        else :
          to-string(s)
      (c:False) :
        fatal("Unexpected end of line")

;Read until EOF from given input stream
defn read-all (i:InputStream) :
  val s = StringBuffer()
  let loop () :
    val c = get-char(i)
    match(c:Char) :
      add(s, c)
      loop()
  to-string(s)

;============================================================
;===================== Main =================================
;============================================================

defn read-projfile () :
  val forms = read-file("scripts/jitpcb.proj")
  parse-syntax[projfile / #projfile!](forms)

defn gen-scripts (pj:ProjFile, platform:Symbol) :
  compile-ex-files(pj, platform)
  make-jitpcb-file()
  make-stanza-file(platform)
  make-build-file(pj, platform)
  make-make-all-files(pj)
  make-devenv-file()

defn main () :
  val options = command-line-arguments()[1 to false]
  val pj = read-projfile()
  val platform = request-platform()
  if contains?(options, "-gen-scripts") :
    gen-scripts(pj, platform)
  else if contains?(options, "-gen-make") :
    val cross-platform = request-cross-platform()
    make-release-file()
    build-bootstrap-compiler(pj)    
    make-lstanza-file(`linux) when cross-platform is Symbol
    make-make-jitpcb-file(pj, platform, cross-platform)
  else :
    setup-directory()
    build-bootstrap-compiler(pj)
    gen-scripts(pj, platform)

try :
  main()
catch (e:Exception) :
  println(e)